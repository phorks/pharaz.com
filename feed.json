{
    "version": "https://jsonfeed.org/version/1",
    "title": "Pharaz Fadaei",
    "home_page_url": "https://pharaz.com",
    "feed_url": "https://pharaz.com/feed.json",
    "description": "Personal Blog",
    "author": {
        "name": "Pharaz Fadaei"
    },
    "items": [
        {
            "id": "https://pharaz.com/2020/08/22/csharp-expression-trees/",
            "content_html": "<p>Have you ever wondered how a property of an object can be passed to a method? I mean the property itself, not its value! Why does it matter to be able to pass a property, you might ask. Let me explain with an example. Let’s say we want to write a method that accepts a string property of an object and prints the name of the property followed by its value. How should this method be written?</p><p>For the sake of demonstration, let’s suppose that we have a <em>Person</em> class that has two string properties, <em>FirstName</em> and <em>LastName</em>. <em>personInstance</em> is an instance of this class.</p><pre><code class=\"language-csharp\">public Person\n{\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n}\n\n//... inside the main method\nPerson personInstance = new Person\n{\n    FirstName = &quot;John&quot;,\n    LastName = &quot;Doe&quot;\n};\n</code></pre><p>The goal here is to write a method <em>PrintProperty</em> in a way that if a property of an object is passed to it, it will print the name and the value of the property. For instance, if the method is called this way, <code>PrintProperty(FirstName property of personInstance)</code>, it will print “FirstName: John”. Now the question is, how can we define this <em>PrintProperty</em> method? How can we pass the property to it?</p><p>First, let’s talk a bit about properties. In order for a property to be accessed at runtime, we need the property name and an object that has that property. Once we have this information, we can find the value of the property with help of <a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection\">reflection</a>. So, the problem is now reduced to finding a way to pass an object and a property name to a method. In this post, I am going to explain three different approaches to address this problem.</p><h2>Approach #1: The naive approach</h2><p>We can simply pass the object and property name, and the rest can be handled by reflection.</p><pre><code class=\"language-csharp\">static void PrintProperty1(object obj, string propertyName)\n{\n    var property = obj.GetType().GetProperty(propertyName);\n\n    Console.WriteLine($&quot;{propertyName}: {property.GetValue(obj)}&quot;);\n}\n\n// ... inside the main method\nPrintProperty1(personInstance, &quot;FirstName&quot;);\n</code></pre><p>Here, we are using a string to identify the property. But what if at some point we decide to change the name of the property to <em>Name</em> instead of <em>FirstName</em>? Or what prevents me from passing “InvalidProperty” as the property name? There’s no way to ensure <em>propertyName</em> is a property of <em>obj</em> at compile-time.</p><h2>Approach #2: Using nameof expression</h2><p>Before C# 6.0, there was no good way to obtain the name of a property programmatically. But C# 6.0 introduced <em>nameof</em> expression that is helpful in this situation.</p><pre><code class=\"language-csharp\">static void PrintProperty2(object obj, string propertyName)\n{\n    var property = obj.GetType().GetProperty(propertyName);\n\n    Console.WriteLine($&quot;{propertyName}: {property.GetValue(obj)}&quot;);\n}\n\n// ... inside the main method\nPrintProperty2(personInstance, nameof(personInstance.FirstName));\n</code></pre><p>As you can see, the body of <em>PrintProperty2</em> is the same as <em>PrintProperty1</em>, what has changed, is how we pass the property name to it. Using <em>nameof</em> expression, if we change name of the property to <em>Name</em> at some point, it won’t compile. But since the parameter is string, I’m not forced to use <em>nameof</em> and still nothing prevents me from passing “InvalidProperty” as the property name. This approach is OK but doesn’t look cool to me. Since what we are trying to achieve, is to pass the <em>FirstName</em> property to the method, wouldn’t it be better if we could simply pass personInstance.FirstName? Well, the answer is we can, somehow! Expression trees are here to help! Before moving on to the third approach, let’s talk about expression trees a bit.</p><p>You can be a C#/.net developer for years and have never heard of expression trees. Before explaining expression trees, I am going to ask you a simple question to test your knowledge of expression trees. Let’s assume that we’re going to assign the following lambda expression to a variable named <em>x</em>. <em>obj</em> is an object of a class that has an int property named <em>prop</em>. What kinds of possible types can replace <code>var</code> keyword below?</p><pre><code class=\"language-csharp\">var x = () =&gt; obj.prop;\n</code></pre><p>If your answer to this question does not include <code>Expression&lt;Func&lt;int&gt;&gt;</code>, you are probably ignorant of expression trees!</p><p>Normally, when you assign an expression, <code>a+b</code> for instance, to a variable <em>x</em>, the expression is computed and its value is assigned to <em>x</em>. So, after it is assigned, <em>x</em> only knows the computed value and has no idea how the value is computed, therefore if you change the value of <em>a</em>, the value of <em>x</em> won’t change. It’s not the same for lambda expressions. If you assign a lambda expression, let’s say <code>() =&gt; a + b</code>, to a variable <em>f</em>, the value <code>a+b</code> is not computed at first. In contrast to the previous case, where the value got computed and stored in <em>x</em>, here, the instruction to produce the value is stored in <em>f</em>. Strictly speaking, <em>f</em> captures variables <em>a</em> and <em>b</em> and every time it gets invoked, it adds these two variables and returns the value. With the help of expression trees, you can create and manipulate these instructions.</p><p>Cool as it may sound, it seems hard to find a real-world situation in which expression trees can come in handy. You might be surprised by the fact that how expression trees are being used in LINQ to Sql. For instance, <code>Where</code> extension method that is applied to <code>IEnumerable&lt;T&gt;</code> and <code>Where</code> extension method that is used for <code>IQueryable&lt;T&gt;</code>, although look similar in usage and name, accept different type of parameters. Former expects a <code>Func&lt;T, bool&gt;</code> as the first parameter while the latter expects a <code>Expression&lt;Func&lt;T, bool&gt;&gt;</code>. You can learn more about this usage <a href=\"https://www.youtube.com/watch?v=ylaxq4koAkU\">here</a>.</p><p>Now, let’s see how expression trees can help us solve our main problem!</p><h2>Approach #3: Expression Trees!</h2><p>As I mentioned above, we can just pass <code>personInstance.FirstName</code> to the method. But if we do so, what the method will get is the value of <code>personInstance.FirstName</code> which is string “John”. So, we can instead pass <code>() =&gt; personInstance.FirstName</code> as an expression to the method and analyse it to find the object and its property member.</p><p><code>() =&gt; personInstance.FirstName</code> as an Expression, is a <code>LambdaExpression</code>, it has a <em>Body</em> property that defines what the lambda expression will return. The <em>Body</em> property in this case is a <code>MemberExpression</code> - since we are trying to access a member of another expression using the dot operator. The member expression itself has an <em>Expression</em> property, which defines the expression that we are trying to access its member and a <em>Member</em> property. <em>Member</em> property of the <code>MemberExpression</code> is a <code>MemberInfo</code> object that has a <em>Name</em> property, which in this case is “FirstName”. There is an implicit level of member accessing here. Since <em>personInstance</em> is defined inside the <em>main</em> method, it cannot be accessed elsewhere, hence, the lambda expression will capture the <em>personInstance</em> object and store it inside a compiler-generated class as a field named <em>personInstance</em>. So <em>personInstance</em> object is a property inside an implicit compiler-generated class. As a result <em>Expression</em> property of the member expression, in this case, is also a <code>MemberExpression</code> with its <em>Member</em> property being a <code>MemberInfo</code> with <em>personInstance</em> name and its <em>Expression</em> being a <code>ConstantExpression</code> that has that compiler-generated class as its value. Following diagram demonstrates how the expression tree of this simple lambda expression will look like.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:521px\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:73.33333333333334%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAAC8ElEQVQ4y41TSUwTYRT+WwwEwQREPZh4kGCEBKMxoFf0qAeiJkaPHtSDF2M46NHlpCgHcY2iEoIYJCJLKe1sLQWmdGg7Xei+2BbaUtrSlbL1OTMYlh6Ql7y8me9/870373s/Qv8sPaES8zGlpC5FKMIQJvFcVEkBFxejCrI/TWBH+fM4LhOhvVh6clwgTKsUV4O43DVLyONBCo/75KOxCInjSwry2AahfG+EvIFjejP5Iqosba5rqN5+vkIr9062bP8lxEXmS0neO9gQM/Xd0ss+Psr7Rq5krb01XVVcQQCUoN/vjXD1D1XExzWPtAUWtJCf1QCEtQDzOkjbsbVV5896Ic89KN6VaMKhRJo5FaL1v4VEAO1BmCNuJCzDrXHz0LtF88ATCBJNXHcivsPpoVdi8PeIkqZulGJfCxwZ8+ctQk/CW1ixlPPyAqyC80PbgTYaEARVwkwhZNiZHQVz8ZgLq+kY/HDq+u3LhzlItNFRUgxB9T7unR9HaV/73RNG6Yt6yHVXbQoZYXYKpZ9lOmn7REamGV0foSV5jVudMYXZN8I8HdTGGEL4haRN7gux0pWIUZaPzWDLKZvcvuYeOLsxV+nWX2oDmofy6dEJGSN1SeghJ/es1vo199FNhIJ+oTsEYeJM1on1LRgllohREoiaRsyrXrITYgphrdxOW5HWsyTqH/dv20EAMe+76Ffe1FhZ1tbSVFJ7/AA/0/2FCdEs9705ZCpqPndnEzyN7gkxAPYKfYip/TbQ0fj2e9tJDiopFO/py091Hb3Y+UlLtN66AEcEdNDQg2jvGBp3U0jvNggdajx0q8qiBJIlgNTjMDajBK2fGSJsw2X8OevLVVuD6z8M3kxI704C60mDzpWcN/lzXzfLdanbEaYmBMUUM8Q1XCeTKE2UmjKSU5hWRuKs7IEjGygWhPRkn8XyAOOsHzDaCvJJC0xZwuCNc4taaH39w/+9VbguXDlliz1nPSk940wkGUciYfCmdWpr9PFfJrfHLkM5VX0AAAAASUVORK5CYII=&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"expression tree\" title=\"expression tree\" src=\"/static/0c48987bbb97379b00fefd263fd6d5c2/bb9c5/expression_trees.png\" srcSet=\"/static/0c48987bbb97379b00fefd263fd6d5c2/e9ff0/expression_trees.png 180w,/static/0c48987bbb97379b00fefd263fd6d5c2/f21e7/expression_trees.png 360w,/static/0c48987bbb97379b00fefd263fd6d5c2/bb9c5/expression_trees.png 521w\" sizes=\"(max-width: 521px) 100vw, 521px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n    </span>\n<em>Expression tree of <code>() =&gt; personInstance.FirstName</code> (the diagram is made using <a href=\"https://app.diagrams.net/\">draw.io</a>)</em></p><p>Now we can use the above information to implement PrintProperty3 method.</p><pre><code class=\"language-csharp\">static void PrintProperty3(Expression&lt;Func&lt;string&gt;&gt; propertyExpression)\n{\n    var memberExpression = propertyExpression.Body as MemberExpression;\n    var implicitMemberExpression = memberExpression.Expression as MemberExpression;\n    var objectName = implicitMemberExpression.Member.Name;\n    var constantExpression = implicitMemberExpression.Expression as ConstantExpression;\n    var owner = constantExpression.Value;\n\n    var obj = owner.GetType().GetField(objectName).GetValue(owner);\n    var property = memberExpression.Member as PropertyInfo;\n\n    Console.WriteLine($&quot;{property.Name}: {property.GetValue(obj)}&quot;);\n}\n\n// ... inside the main method\nPrintProperty3(() =&gt; personInstance.FirstName);\n</code></pre><p>In this approach, the method body is longer compared to the ones in previous approaches. However, when it comes to using it, passing the property is more straightforward. We can feel that we’re actually passing a property. In this case if we decide to rename <em>FirstName</em> property to Name we will get a compilation error. This approach is not completely safe though, we can pass <code>() =&gt; “Hello”</code> as the parameter! But at least we’re not relying on strings to specify properties. I personally prefer not to use nameof expression unless there is no better choice.</p><p>We just learned a new technique to specify properties. In the next part I’ll explain how this technique can be used in WPF/Xamarin.Forms applications. If you don’t know or care about WPF or Xamarin.Forms you can skip this part.</p><h3>Applications in WPF/Xamarin.Forms</h3><p><abbr title=\"Extensible Application Markup Language\">XAML</abbr>-based technologies in C# like WPF or Xamarin.Forms, provide an <code>ICommand</code> interface to implement command design pattern. It is common among developers to use a single <em>DelegateCommand</em> -or <em>RelayCommand</em>– class to create new commands instead of creating a new class and implementing <code>ICommand</code> for each new command. Let’s assume that you have a sign up form. There is a “I Agree to the Terms” checkbox that is bound to a bool property named Agreed in your view model. There is also a button that must be disabled if the checkbox is not checked. You create your command inside your view model this way:</p><pre><code class=\"language-csharp\">// define SubmitCommand property inside the view model\nDelegateCommand SubmitCommand { get; set; }\n\n// ... inside the constructor\nthis.SubmitCommand = new DelegateCommand(this.Submit(), () =&gt; this.Agreed);\n</code></pre><p>Obviously, the submit button on your form must be bound to <em>SubmitCommand</em> property. This way, even if you check the checkbox, you’ll notice that the button won’t be enabled. That’s because the button won’t automatically check your CanExecute command to see if it’s changed. If your CanExecute function depends on some of the properties in your view model, you should fire CanExecute event of DelegateCommand manually every time one of these properties is changed. It’s fine to add <code>this.SubmitCommand.RaiseCanExecuteChanged()</code> to the getter of <em>Agreed</em> property. But suppose that you have many commands that depend on <em>Agreed</em> property and also your <em>SubmitCommand</em> depends on some other properties. You’ll end up with ugly getters, and it would become a headache to manage their relations. However, you can take advantage of <code>INotifyPropertyChanged</code> interface and use the technique explained above to tell your commands to observe the properties. You can implement a method in your DelegateCommand class to watch for property changes. And then you can simply initialize your <em>SubmitCommand</em> this way:</p><pre><code class=\"language-csharp\">this.SubmitCommand = new DelegateCommand(this.Submit(), () =&gt; this.Agreed);\nthis.SubmitCommand.ObservesProperty(() =&gt; this.Agreed);\n</code></pre><p>And you’re done.</p><p>As a bonus, Prism library has a nice implementation of <em>DelegateCommand</em> class with <em>ObservesProperty</em> method. You can check it out on <a href=\"https://github.com/PrismLibrary/Prism/blob/master/src/Prism.Core/Commands/DelegateCommand.cs\">their github</a>.</p>",
            "url": "https://pharaz.com/2020/08/22/csharp-expression-trees/",
            "title": "C# Expression Trees!",
            "date_modified": "2020-08-22T00:00:00.000Z"
        },
        {
            "id": "https://pharaz.com/2020/08/20/welcome/",
            "content_html": "<p>Creating my first blog on <a href=\"https://fa.wikipedia.org/wiki/%D8%A8%D9%84%D8%A7%DA%AF%D9%81%D8%A7\">Blogfa</a> when I was 10, has been one of the geekiest things I’ve ever done in my life. Being able to finally have an address of my own on the web was like a dream come true for me. Since then, I have created a number of blogs, none of which have been successful. Despite my inner desire to write, I have never been a successful blogger, actually, I have never been a blogger at all! All I did was sporadically write some random blog posts and then lose all the interest and motivation!</p><p>This time it’s going to be different, I have a new set of motivations and reasons to blog! I have realized that to be a successful blogger, it takes desire, consistency, and planning.</p><p>I intend to share my experiences, opinions, and adventures here. You may find posts mostly about computers, programming, games, and puzzles.</p>",
            "url": "https://pharaz.com/2020/08/20/welcome/",
            "title": "Welcome!",
            "date_modified": "2020-08-20T00:00:00.000Z"
        }
    ]
}