<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Pharaz Fadaei</title>
        <link>https://pharaz.com</link>
        <description>Personal Blog</description>
        <lastBuildDate>Tue, 23 Feb 2021 16:20:32 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>GatsbyJS</generator>
        <copyright>All rights reserved 2021, Pharaz Fadaei</copyright>
        <item>
            <title><![CDATA[Automatic Component State Management in Blazor using INotifyPropertyChanged and INotifyCollectionChanged]]></title>
            <link>https://pharaz.com/2020/02/19/blazor-reactivity/</link>
            <guid>https://pharaz.com/2020/02/19/blazor-reactivity/</guid>
            <pubDate>Tue, 23 Feb 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>In Blazor, changes to the state of a component become visible to the user when the component re-renders. Blazor has some conventions to make a component automatically re-render when it thinks there is a chance for the component‚Äôs state to be changed. According to <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/rendering?view=aspnetcore-5.0">Microsoft docs</a>, Blazor considers the following situations as the sources of state-changes and will re-render the component accordingly:</p><ol><li>When the set of parameters of a component is updated by its parent component.</li><li>When a cascading value is updated.</li><li>When an event on the component is raised or an external EventCallback that the component is subscribed to is invoked.</li><li>When <code>StateHasChanged</code> method of the component is explicitly called.</li></ol><p>In simple scenarios, the first 3 conventions will be enough to keep your components reactive. But let your models and the relationship between your components get complicated, and you will most often than not find yourself explicitly calling <code>StateHasChanged</code> to make your components re-render.</p><p>A common source of a state-change is a modification to a variable that is used (through binding) to render the component in the most recent render cycle. A variable can be a member (field or property) of the component (possibly a parameter), a nested member of direct members of the component or an item of a collection member of the component. Some <abbr title="User Interface">UI</abbr> frameworks already have the mechanisms to detect such modifications and will automatically make the component re-render (e.g. <a href="https://vuejs.org/v2/guide/reactivity.html">the reactivity system of Vue.js</a> does so by replacing <code>data</code> of a component with proxies that are able to notify the component when they are changed, bindings in WPF/Xamarin.Forms are able to track changes by subscribing to <code>INotifyPropertyChanged</code> and <code>INotifyCollectionChanged</code> instances present in the binding path). But Blazor does not react to such changes if the source of the change does not fall into one of the conventions explained above.</p><p>Consider the following sample component:</p><pre><code class="language-csharp">Name: @(Person.Name)

&lt;ul&gt;
  @foreach (var skill in Person.Skills)
  {
    &lt;li @key=&quot;skill&quot;&gt;@(skill.Title)&lt;/li&gt;
  }
&lt;/ul&gt;

&lt;ChildComponent Person=&quot;@Person&quot; /&gt;

@code {
  [Parameter] public Person Person { get; set; }
}
</code></pre><p>Here if the child component changes <code>Person.Name</code>, adds a skill to <code>Person.Skills</code>, or changes the title of an existing skill, our component has no way to realize that it should re-render to reflect the changes, unless we modify the child component or our model class to make them notify our component when <code>Person.Name</code> is changed, <code>Person.Skills</code> collection is modified, or <code>skill.Title</code> is changed for all of the existing skills in <code>Person.Skills</code> and we modify our component to let Blazor know that the state has changed (by calling <code>StateHasChanged</code>) as the result of these notifications. Just imagine the amount of boilerplate code we need to write for every variable that the rendering of our component relies on!</p><p>Fortunately, the infrastructure to let an object notify its changes is already available in C#. The key is to make <code>Person</code> and <code>Skill</code> classes implement <a href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.inotifypropertychanged?view=net-5.0">INotifyPropertyChanged</a> and raise <code>PropertyChanged</code> event when <code>Person.Name</code> and <code>Skill.Title</code> get changed and to use a collection that implements <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.specialized.inotifycollectionchanged?view=net-5.0">INotifyCollectionChanged</a> (like <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.objectmodel.observablecollection-1?view=net-5.0">ObservableCollection&lt;T&gt;</a>) as the value of <code>Person.Skills</code>.</p><p>In Xaml-based frameworks you can use these two interfaces in your models and the framework will take care of handling the change events to update the <abbr title="User Interface">UI</abbr>. Unfortunately, Blazor is ignorant about these interfaces. <a href="https://github.com/phorks/phork-blazor/"><em>Phork.Blazor.Reactivity</em></a> is a library -which I‚Äôm the author of- that brings the support of these two interfaces to Blazor!</p><p>Using <em>Phork.Blazor.Reactivity</em>, we can apply the following simple changes to the above component to make it work as expected! (Assuming our models are modified to implement <code>INotifyPropertyChanged</code> and use <code>ObservableCollection&lt;T&gt;</code> correctly and <em>Phork.Blazor.Reactivity</em> is installed and configured in our project)</p><pre><code class="language-html">@inherits ReactiveComponentBase

Name: @Observed(() =&gt; Person.Name)

&lt;ul&gt;
  @foreach (var skill in Observed(() =&gt; Person.Skills))
  {
    &lt;li @key=&quot;skill&quot;&gt;@Observed(() =&gt; skill.Title)&lt;/li&gt;
  }
&lt;/ul&gt;

&lt;ChildComponent Person=&quot;@Person&quot; /&gt;

@code {
  [Parameter] public Person Person { get; set; }
}
</code></pre><p>With <em>Phork.Blazor.Reactivity</em>, you can take advantage of <code>INotifyPropertyChanged</code> and <code>INotifyCollectionChanged</code> to create reactive components. The library will take care of watching changes for you. But it doesn‚Äôt end here, there are more features available in the library that you can learn about in its documentation.</p><p>Find out more:</p><ul><li><a href="https://github.com/phorks/phork-blazor/blob/main/docs/reactivity/README.md">Documentation</a></li><li><a href="https://github.com/phorks/phork-blazor/">GitHub Repository</a></li><li><a href="https://www.nuget.org/packages/Phork.Blazor.Reactivity">NuGet package</a></li></ul><blockquote><p>üéØ <strong>Bonus Tip</strong>: If you plan to use <abbr title="Model View ViewModel">MVVM</abbr> in your Blazor application, using <em>Phork.Blazor.Reactivty</em> will give you the luxury of reusing your existing cross-platform view models from your WPF/Xamarin.Forms applications with less effort.</p></blockquote>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Automatic Component State Management in Blazor using INotifyPropertyChanged and INotifyCollectionChanged]]></title>
            <link>https://pharaz.com/2020/02/23/blazor-reactivity/</link>
            <guid>https://pharaz.com/2020/02/23/blazor-reactivity/</guid>
            <pubDate>Tue, 23 Feb 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>In Blazor, changes to the state of a component become visible to the user when the component re-renders. Blazor has some conventions to make a component automatically re-render when it thinks there is a chance for the component‚Äôs state to be changed. According to <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/rendering?view=aspnetcore-5.0">Microsoft docs</a>, Blazor considers the following situations as the sources of state-changes and will re-render the component accordingly:</p><ol><li>When the set of parameters of a component is updated by its parent component.</li><li>When a cascading value is updated.</li><li>When an event on the component is raised or an external EventCallback that the component is subscribed to is invoked.</li><li>When <code>StateHasChanged</code> method of the component is explicitly called.</li></ol><p>In simple scenarios, the first 3 conventions will be enough to keep your components reactive. But let your models and the relationship between your components get complicated, and you will most often than not find yourself explicitly calling <code>StateHasChanged</code> to make your components re-render.</p><p>A common source of a state-change is a modification to a variable that is used (through binding) to render the component in the most recent render cycle. A variable can be a member (field or property) of the component (possibly a parameter), a nested member of direct members of the component or an item of a collection member of the component. Some <abbr title="User Interface">UI</abbr> frameworks already have the mechanisms to detect such modifications and will automatically make the component re-render (e.g. <a href="https://vuejs.org/v2/guide/reactivity.html">the reactivity system of Vue.js</a> does so by replacing <code>data</code> of a component with proxies that are able to notify the component when they are changed, bindings in WPF/Xamarin.Forms are able to track changes by subscribing to <code>INotifyPropertyChanged</code> and <code>INotifyCollectionChanged</code> instances present in the binding path). But Blazor does not react to such changes if the source of the change does not fall into one of the conventions explained above.</p><p>Consider the following sample component:</p><pre><code class="language-csharp">Name: @(Person.Name)

&lt;ul&gt;
  @foreach (var skill in Person.Skills)
  {
    &lt;li @key=&quot;skill&quot;&gt;@(skill.Title)&lt;/li&gt;
  }
&lt;/ul&gt;

&lt;ChildComponent Person=&quot;@Person&quot; /&gt;

@code {
  [Parameter] public Person Person { get; set; }
}
</code></pre><p>Here if the child component changes <code>Person.Name</code>, adds a skill to <code>Person.Skills</code>, or changes the title of an existing skill, our component has no way to realize that it should re-render to reflect the changes, unless we modify the child component or our model class to make them notify our component when <code>Person.Name</code> is changed, <code>Person.Skills</code> collection is modified, or <code>skill.Title</code> is changed for all of the existing skills in <code>Person.Skills</code> and we modify our component to let Blazor know that the state has changed (by calling <code>StateHasChanged</code>) as the result of these notifications. Just imagine the amount of boilerplate code we need to write for every variable that the rendering of our component relies on!</p><p>Fortunately, the infrastructure to let an object notify its changes is already available in C#. The key is to make <code>Person</code> and <code>Skill</code> classes implement <a href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.inotifypropertychanged?view=net-5.0">INotifyPropertyChanged</a> and raise <code>PropertyChanged</code> event when <code>Person.Name</code> and <code>Skill.Title</code> get changed and to use a collection that implements <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.specialized.inotifycollectionchanged?view=net-5.0">INotifyCollectionChanged</a> (like <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.objectmodel.observablecollection-1?view=net-5.0">ObservableCollection&lt;T&gt;</a>) as the value of <code>Person.Skills</code>.</p><p>In Xaml-based frameworks you can use these two interfaces in your models and the framework will take care of handling the change events to update the <abbr title="User Interface">UI</abbr>. Unfortunately, Blazor is ignorant about these interfaces. <a href="https://github.com/phorks/phork-blazor/"><em>Phork.Blazor.Reactivity</em></a> is a library -which I‚Äôm the author of- that brings the support of these two interfaces to Blazor!</p><p>Using <em>Phork.Blazor.Reactivity</em>, we can apply the following simple changes to the above component to make it reactive! (Assuming our models are modified to implement <code>INotifyPropertyChanged</code> and use <code>ObservableCollection&lt;T&gt;</code> correctly and <em>Phork.Blazor.Reactivity</em> is installed and configured in our project)</p><pre><code class="language-html">@inherits ReactiveComponentBase

Name: @Observed(() =&gt; Person.Name)

&lt;ul&gt;
  @foreach (var skill in Observed(() =&gt; Person.Skills))
  {
    &lt;li @key=&quot;skill&quot;&gt;@Observed(() =&gt; skill.Title)&lt;/li&gt;
  }
&lt;/ul&gt;

&lt;ChildComponent Person=&quot;@Person&quot; /&gt;

@code {
  [Parameter] public Person Person { get; set; }
}
</code></pre><p>With <em>Phork.Blazor.Reactivity</em>, you can take advantage of <code>INotifyPropertyChanged</code> and <code>INotifyCollectionChanged</code> to create reactive components. The library will take care of watching changes for you. It doesn‚Äôt end here, there are more features available in the library that you can learn about in its documentation.</p><p>Find out more:</p><ul><li><a href="https://github.com/phorks/phork-blazor/blob/main/docs/reactivity/README.md">Documentation</a></li><li><a href="https://github.com/phorks/phork-blazor/">GitHub Repository</a></li><li><a href="https://www.nuget.org/packages/Phork.Blazor.Reactivity">NuGet package</a></li></ul><blockquote><p>üéØ <strong>Bonus Tip</strong>: If you plan to use <abbr title="Model View ViewModel">MVVM</abbr> in your Blazor application, using <em>Phork.Blazor.Reactivty</em> will give you the luxury of reusing your existing cross-platform view models from your WPF/Xamarin.Forms applications with less effort.</p></blockquote>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[C# Expression Trees!]]></title>
            <link>https://pharaz.com/2020/08/22/csharp-expression-trees/</link>
            <guid>https://pharaz.com/2020/08/22/csharp-expression-trees/</guid>
            <pubDate>Sat, 22 Aug 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>Have you ever wondered how a property of an object can be passed to a method? I mean the property itself, not its value! Why does it matter to be able to pass a property, you might ask. Let me explain with an example. Let‚Äôs say we want to write a method that accepts a string property of an object and prints the name of the property followed by its value. How should this method be written?</p><p>For the sake of demonstration, let‚Äôs suppose that we have a <em>Person</em> class that has two string properties, <em>FirstName</em> and <em>LastName</em>. <em>personInstance</em> is an instance of this class.</p><pre><code class="language-csharp">public Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

//... inside the main method
Person personInstance = new Person
{
    FirstName = &quot;John&quot;,
    LastName = &quot;Doe&quot;
};
</code></pre><p>The goal here is to write a method <em>PrintProperty</em> in a way that if a property of an object is passed to it, it will print the name and the value of the property. For instance, if the method is called this way, <code>PrintProperty(FirstName property of personInstance)</code>, it will print ‚ÄúFirstName: John‚Äù. Now the question is, how can we define this <em>PrintProperty</em> method? How can we pass the property to it?</p><p>First, let‚Äôs talk a bit about properties. In order for a property to be accessed at runtime, we need the property name and an object that has that property. Once we have this information, we can find the value of the property with help of <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection">reflection</a>. So, the problem is now reduced to finding a way to pass an object and a property name to a method. In this post, I am going to explain three different approaches to address this problem.</p><h2>Approach #1: The naive approach</h2><p>We can simply pass the object and property name, and the rest can be handled by reflection.</p><pre><code class="language-csharp">static void PrintProperty1(object obj, string propertyName)
{
    var property = obj.GetType().GetProperty(propertyName);

    Console.WriteLine($&quot;{propertyName}: {property.GetValue(obj)}&quot;);
}

// ... inside the main method
PrintProperty1(personInstance, &quot;FirstName&quot;);
</code></pre><p>Here, we are using a string to identify the property. But what if at some point we decide to change the name of the property to <em>Name</em> instead of <em>FirstName</em>? Or what prevents me from passing ‚ÄúInvalidProperty‚Äù as the property name? There‚Äôs no way to ensure <em>propertyName</em> is a property of <em>obj</em> at compile-time.</p><h2>Approach #2: Using nameof expression</h2><p>Before C# 6.0, there was no good way to obtain the name of a property programmatically. But C# 6.0 introduced <em>nameof</em> expression that is helpful in this situation.</p><pre><code class="language-csharp">static void PrintProperty2(object obj, string propertyName)
{
    var property = obj.GetType().GetProperty(propertyName);

    Console.WriteLine($&quot;{propertyName}: {property.GetValue(obj)}&quot;);
}

// ... inside the main method
PrintProperty2(personInstance, nameof(personInstance.FirstName));
</code></pre><p>As you can see, the body of <em>PrintProperty2</em> is the same as <em>PrintProperty1</em>, what has changed, is how we pass the property name to it. Using <em>nameof</em> expression, if we change name of the property to <em>Name</em> at some point, it won‚Äôt compile. But since the parameter is string, I‚Äôm not forced to use <em>nameof</em> and still nothing prevents me from passing ‚ÄúInvalidProperty‚Äù as the property name. This approach is OK but doesn‚Äôt look cool to me. Since what we are trying to achieve, is to pass the <em>FirstName</em> property to the method, wouldn‚Äôt it be better if we could simply pass personInstance.FirstName? Well, the answer is we can, somehow! Expression trees are here to help! Before moving on to the third approach, let‚Äôs talk about expression trees a bit.</p><p>You can be a C#/.net developer for years and have never heard of expression trees. Before explaining expression trees, I am going to ask you a simple question to test your knowledge of expression trees. Let‚Äôs assume that we‚Äôre going to assign the following lambda expression to a variable named <em>x</em>. <em>obj</em> is an object of a class that has an int property named <em>prop</em>. What kinds of possible types can replace <code>var</code> keyword below?</p><pre><code class="language-csharp">var x = () =&gt; obj.prop;
</code></pre><p>If your answer to this question does not include <code>Expression&lt;Func&lt;int&gt;&gt;</code>, you are probably ignorant of expression trees!</p><p>Normally, when you assign an expression, <code>a+b</code> for instance, to a variable <em>x</em>, the expression is computed and its value is assigned to <em>x</em>. So, after it is assigned, <em>x</em> only knows the computed value and has no idea how the value is computed, therefore if you change the value of <em>a</em>, the value of <em>x</em> won‚Äôt change. It‚Äôs not the same for lambda expressions. If you assign a lambda expression, let‚Äôs say <code>() =&gt; a + b</code>, to a variable <em>f</em>, the value <code>a+b</code> is not computed at first. In contrast to the previous case, where the value got computed and stored in <em>x</em>, here, the instruction to produce the value is stored in <em>f</em>. Strictly speaking, <em>f</em> captures variables <em>a</em> and <em>b</em> and every time it gets invoked, it adds these two variables and returns the value. With the help of expression trees, you can create and manipulate these instructions.</p><p>Cool as it may sound, it seems hard to find a real-world situation in which expression trees can come in handy. You might be surprised by the fact that how expression trees are being used in LINQ to Sql. For instance, <code>Where</code> extension method that is applied to <code>IEnumerable&lt;T&gt;</code> and <code>Where</code> extension method that is used for <code>IQueryable&lt;T&gt;</code>, although look similar in usage and name, accept different type of parameters. Former expects a <code>Func&lt;T, bool&gt;</code> as the first parameter while the latter expects a <code>Expression&lt;Func&lt;T, bool&gt;&gt;</code>. You can learn more about this usage <a href="https://www.youtube.com/watch?v=ylaxq4koAkU">here</a>.</p><p>Now, let‚Äôs see how expression trees can help us solve our main problem!</p><h2>Approach #3: Expression Trees!</h2><p>As I mentioned above, we can just pass <code>personInstance.FirstName</code> to the method. But if we do so, what the method will get is the value of <code>personInstance.FirstName</code> which is string ‚ÄúJohn‚Äù. So, we can instead pass <code>() =&gt; personInstance.FirstName</code> as an expression to the method and analyse it to find the object and its property member.</p><p><code>() =&gt; personInstance.FirstName</code> as an Expression, is a <code>LambdaExpression</code>, it has a <em>Body</em> property that defines what the lambda expression will return. The <em>Body</em> property in this case is a <code>MemberExpression</code> - since we are trying to access a member of another expression using the dot operator. The member expression itself has an <em>Expression</em> property, which defines the expression that we are trying to access its member and a <em>Member</em> property. <em>Member</em> property of the <code>MemberExpression</code> is a <code>MemberInfo</code> object that has a <em>Name</em> property, which in this case is ‚ÄúFirstName‚Äù. There is an implicit level of member accessing here. Since <em>personInstance</em> is defined inside the <em>main</em> method, it cannot be accessed elsewhere, hence, the lambda expression will capture the <em>personInstance</em> object and store it inside a compiler-generated class as a field named <em>personInstance</em>. So <em>personInstance</em> object is a property inside an implicit compiler-generated class. As a result <em>Expression</em> property of the member expression, in this case, is also a <code>MemberExpression</code> with its <em>Member</em> property being a <code>MemberInfo</code> with <em>personInstance</em> name and its <em>Expression</em> being a <code>ConstantExpression</code> that has that compiler-generated class as its value. Following diagram demonstrates how the expression tree of this simple lambda expression will look like.</p><p><span class="gatsby-resp-image-wrapper" style="position:relative;display:block;margin-left:auto;margin-right:auto;max-width:521px">
      <span class="gatsby-resp-image-background-image" style="padding-bottom:73.33333333333334%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAAC8ElEQVQ4y41TSUwTYRT+WwwEwQREPZh4kGCEBKMxoFf0qAeiJkaPHtSDF2M46NHlpCgHcY2iEoIYJCJLKe1sLQWmdGg7Xei+2BbaUtrSlbL1OTMYlh6Ql7y8me9/870373s/Qv8sPaES8zGlpC5FKMIQJvFcVEkBFxejCrI/TWBH+fM4LhOhvVh6clwgTKsUV4O43DVLyONBCo/75KOxCInjSwry2AahfG+EvIFjejP5Iqosba5rqN5+vkIr9062bP8lxEXmS0neO9gQM/Xd0ss+Psr7Rq5krb01XVVcQQCUoN/vjXD1D1XExzWPtAUWtJCf1QCEtQDzOkjbsbVV5896Ic89KN6VaMKhRJo5FaL1v4VEAO1BmCNuJCzDrXHz0LtF88ATCBJNXHcivsPpoVdi8PeIkqZulGJfCxwZ8+ctQk/CW1ixlPPyAqyC80PbgTYaEARVwkwhZNiZHQVz8ZgLq+kY/HDq+u3LhzlItNFRUgxB9T7unR9HaV/73RNG6Yt6yHVXbQoZYXYKpZ9lOmn7REamGV0foSV5jVudMYXZN8I8HdTGGEL4haRN7gux0pWIUZaPzWDLKZvcvuYeOLsxV+nWX2oDmofy6dEJGSN1SeghJ/es1vo199FNhIJ+oTsEYeJM1on1LRgllohREoiaRsyrXrITYgphrdxOW5HWsyTqH/dv20EAMe+76Ffe1FhZ1tbSVFJ7/AA/0/2FCdEs9705ZCpqPndnEzyN7gkxAPYKfYip/TbQ0fj2e9tJDiopFO/py091Hb3Y+UlLtN66AEcEdNDQg2jvGBp3U0jvNggdajx0q8qiBJIlgNTjMDajBK2fGSJsw2X8OevLVVuD6z8M3kxI704C60mDzpWcN/lzXzfLdanbEaYmBMUUM8Q1XCeTKE2UmjKSU5hWRuKs7IEjGygWhPRkn8XyAOOsHzDaCvJJC0xZwuCNc4taaH39w/+9VbguXDlliz1nPSk940wkGUciYfCmdWpr9PFfJrfHLkM5VX0AAAAASUVORK5CYII=&#x27;);background-size:cover;display:block"></span>
  <img class="gatsby-resp-image-image" alt="expression tree" title="expression tree" src="/static/0c48987bbb97379b00fefd263fd6d5c2/bb9c5/expression_trees.png" srcSet="/static/0c48987bbb97379b00fefd263fd6d5c2/e9ff0/expression_trees.png 180w,/static/0c48987bbb97379b00fefd263fd6d5c2/f21e7/expression_trees.png 360w,/static/0c48987bbb97379b00fefd263fd6d5c2/bb9c5/expression_trees.png 521w" sizes="(max-width: 521px) 100vw, 521px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0" loading="lazy"/>
    </span>
<em>Expression tree of <code>() =&gt; personInstance.FirstName</code> (the diagram is made using <a href="https://app.diagrams.net/">draw.io</a>)</em></p><p>Now we can use the above information to implement PrintProperty3 method.</p><pre><code class="language-csharp">static void PrintProperty3(Expression&lt;Func&lt;string&gt;&gt; propertyExpression)
{
    var memberExpression = propertyExpression.Body as MemberExpression;
    var implicitMemberExpression = memberExpression.Expression as MemberExpression;
    var objectName = implicitMemberExpression.Member.Name;
    var constantExpression = implicitMemberExpression.Expression as ConstantExpression;
    var owner = constantExpression.Value;

    var obj = owner.GetType().GetField(objectName).GetValue(owner);
    var property = memberExpression.Member as PropertyInfo;

    Console.WriteLine($&quot;{property.Name}: {property.GetValue(obj)}&quot;);
}

// ... inside the main method
PrintProperty3(() =&gt; personInstance.FirstName);
</code></pre><p>In this approach, the method body is longer compared to the ones in previous approaches. However, when it comes to using it, passing the property is more straightforward. We can feel that we‚Äôre actually passing a property. In this case if we decide to rename <em>FirstName</em> property to Name we will get a compilation error. This approach is not completely safe though, we can pass <code>() =&gt; ‚ÄúHello‚Äù</code> as the parameter! But at least we‚Äôre not relying on strings to specify properties. I personally prefer not to use nameof expression unless there is no better choice.</p><p>We just learned a new technique to specify properties. In the next part I‚Äôll explain how this technique can be used in WPF/Xamarin.Forms applications. If you don‚Äôt know or care about WPF or Xamarin.Forms you can skip this part.</p><h3>Applications in WPF/Xamarin.Forms</h3><p><abbr title="Extensible Application Markup Language">XAML</abbr>-based technologies in C# like WPF or Xamarin.Forms, provide an <code>ICommand</code> interface to implement command design pattern. It is common among developers to use a single <em>DelegateCommand</em> -or <em>RelayCommand</em>‚Äì class to create new commands instead of creating a new class and implementing <code>ICommand</code> for each new command. Let‚Äôs assume that you have a sign up form. There is a ‚ÄúI Agree to the Terms‚Äù checkbox that is bound to a bool property named Agreed in your view model. There is also a button that must be disabled if the checkbox is not checked. You create your command inside your view model this way:</p><pre><code class="language-csharp">// define SubmitCommand property inside the view model
DelegateCommand SubmitCommand { get; set; }

// ... inside the constructor
this.SubmitCommand = new DelegateCommand(this.Submit(), () =&gt; this.Agreed);
</code></pre><p>Obviously, the submit button on your form must be bound to <em>SubmitCommand</em> property. This way, even if you check the checkbox, you‚Äôll notice that the button won‚Äôt be enabled. That‚Äôs because the button won‚Äôt automatically check your CanExecute command to see if it‚Äôs changed. If your CanExecute function depends on some of the properties in your view model, you should fire CanExecute event of DelegateCommand manually every time one of these properties is changed. It‚Äôs fine to add <code>this.SubmitCommand.RaiseCanExecuteChanged()</code> to the getter of <em>Agreed</em> property. But suppose that you have many commands that depend on <em>Agreed</em> property and also your <em>SubmitCommand</em> depends on some other properties. You‚Äôll end up with ugly getters, and it would become a headache to manage their relations. However, you can take advantage of <code>INotifyPropertyChanged</code> interface and use the technique explained above to tell your commands to observe the properties. You can implement a method in your DelegateCommand class to watch for property changes. And then you can simply initialize your <em>SubmitCommand</em> this way:</p><pre><code class="language-csharp">this.SubmitCommand = new DelegateCommand(this.Submit(), () =&gt; this.Agreed);
this.SubmitCommand.ObservesProperty(() =&gt; this.Agreed);
</code></pre><p>And you‚Äôre done.</p><p>As a bonus, Prism library has a nice implementation of <em>DelegateCommand</em> class with <em>ObservesProperty</em> method. You can check it out on <a href="https://github.com/PrismLibrary/Prism/blob/master/src/Prism.Core/Commands/DelegateCommand.cs">their github</a>.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Welcome!]]></title>
            <link>https://pharaz.com/2020/08/20/welcome/</link>
            <guid>https://pharaz.com/2020/08/20/welcome/</guid>
            <pubDate>Thu, 20 Aug 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>Creating my first blog on <a href="https://fa.wikipedia.org/wiki/%D8%A8%D9%84%D8%A7%DA%AF%D9%81%D8%A7">Blogfa</a> when I was 10, has been one of the geekiest things I‚Äôve ever done in my life. Being able to finally have an address of my own on the web was like a dream come true for me. Since then, I have created a number of blogs, none of which have been successful. Despite my inner desire to write, I have never been a successful blogger, actually, I have never been a blogger at all! All I did was sporadically write some random blog posts and then lose all the interest and motivation!</p><p>This time it‚Äôs going to be different, I have a new set of motivations and reasons to blog! I have realized that to be a successful blogger, it takes desire, consistency, and planning.</p><p>I intend to share my experiences, opinions, and adventures here. You may find posts mostly about computers, programming, games, and puzzles.</p>]]></content:encoded>
        </item>
    </channel>
</rss>