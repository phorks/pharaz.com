<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://pharaz.com/feed.xml" rel="self" type="application/atom+xml"/><link href="https://pharaz.com/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-09-15T16:42:45+00:00</updated><id>https://pharaz.com/feed.xml</id><title type="html">Pharaz Fadaei</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Automatic Component State Management in Blazor using INotifyPropertyChanged and INotifyCollectionChanged</title><link href="https://pharaz.com/2021/02/23/blazor-reactivity/" rel="alternate" type="text/html" title="Automatic Component State Management in Blazor using INotifyPropertyChanged and INotifyCollectionChanged"/><published>2021-02-23T00:00:00+00:00</published><updated>2021-02-23T00:00:00+00:00</updated><id>https://pharaz.com/2021/02/23/blazor-reactivity</id><content type="html" xml:base="https://pharaz.com/2021/02/23/blazor-reactivity/"><![CDATA[<p>In Blazor, changes to the state of a component become visible to the user when the component re-renders. Blazor has some conventions to make a component automatically re-render when it thinks there is a chance for the component‚Äôs state to be changed. However these conventions might sometimes fail to detect changes that actually require a re-render. </p> <p>According to <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/rendering?view=aspnetcore-5.0">Microsoft docs</a>, Blazor considers the following situations as the sources of state-changes and will re-render the component accordingly:</p> <ol> <li>When the set of parameters of a component is updated by its parent component.</li> <li>When a cascading value is updated.</li> <li>When an event on the component is raised or an external EventCallback that the component is subscribed to is invoked.</li> <li>When `StateHasChanged` method of the component is explicitly called.</li> </ol> <p>In simple scenarios, the first 3 conventions will be enough to keep your components reactive. But let your models and the relationship between your components get complicated, and you will most often than not find yourself explicitly calling <code class="language-plaintext highlighter-rouge">StateHasChanged</code> to make your components re-render.</p> <p>A common source of a state-change is a modification to a variable that is used (through binding) to render the component in the most recent render cycle. A variable can be a member (field or property) of the component (possibly a parameter), a nested member of direct members of the component or an item of a collection member of the component. Some UI frameworks already have the mechanisms to detect such modifications and will automatically make the component re-render (e.g. <a href="https://vuejs.org/v2/guide/reactivity.html">the reactivity system of Vue.js</a> does so by replacing <code class="language-plaintext highlighter-rouge">data</code> of a component with proxies that are able to notify the component when they are changed, bindings in WPF/Xamarin.Forms are able to track changes by subscribing to <code class="language-plaintext highlighter-rouge">INotifyPropertyChanged</code> and <code class="language-plaintext highlighter-rouge">INotifyCollectionChanged</code> instances present in the binding path). But Blazor does not react to such changes if the source of the change does not fall into one of the conventions explained above.</p> <p>Consider the following sample component:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Name</span><span class="p">:</span> <span class="err">@</span><span class="p">(</span><span class="n">Person</span><span class="p">.</span><span class="n">Name</span><span class="p">)</span>

<span class="p">&lt;</span><span class="n">ul</span><span class="p">&gt;</span>
  <span class="nf">@foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">skill</span> <span class="k">in</span> <span class="n">Person</span><span class="p">.</span><span class="n">Skills</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">&lt;</span><span class="n">li</span> <span class="n">@key</span><span class="p">=</span><span class="s">"skill"</span><span class="p">&gt;</span><span class="err">@</span><span class="p">(</span><span class="n">skill</span><span class="p">.</span><span class="n">Title</span><span class="p">)&lt;/</span><span class="n">li</span><span class="p">&gt;</span>
  <span class="p">}</span>
<span class="p">&lt;/</span><span class="n">ul</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="n">ChildComponent</span> <span class="n">Person</span><span class="p">=</span><span class="s">"@Person"</span> <span class="p">/&gt;</span>

<span class="n">@code</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">Parameter</span><span class="p">]</span> <span class="k">public</span> <span class="n">Person</span> <span class="n">Person</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Here if the child component changes <code class="language-plaintext highlighter-rouge">Person.Name</code>, adds a skill to <code class="language-plaintext highlighter-rouge">Person.Skills</code>, or changes the title of an existing skill, our component has no way to realize that it should re-render to reflect the changes, unless we modify the child component or our model class to make them notify our component when <code class="language-plaintext highlighter-rouge">Person.Name</code> is changed, <code class="language-plaintext highlighter-rouge">Person.Skills</code> collection is modified, or <code class="language-plaintext highlighter-rouge">skill.Title</code> is changed for all of the existing skills in <code class="language-plaintext highlighter-rouge">Person.Skills</code> and we modify our component to let Blazor know that the state has changed (by calling <code class="language-plaintext highlighter-rouge">StateHasChanged</code>) as the result of these notifications. Just imagine the amount of boilerplate code we need to write for every variable that the rendering of our component relies on!</p> <p>Fortunately, the infrastructure to let an object notify its changes is already available in .NET. The key is to make <code class="language-plaintext highlighter-rouge">Person</code> and <code class="language-plaintext highlighter-rouge">Skill</code> classes implement <a href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.inotifypropertychanged?view=net-5.0">INotifyPropertyChanged</a> and raise <code class="language-plaintext highlighter-rouge">PropertyChanged</code> event when <code class="language-plaintext highlighter-rouge">Person.Name</code> and <code class="language-plaintext highlighter-rouge">Skill.Title</code> get changed and to use a collection that implements <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.specialized.inotifycollectionchanged?view=net-5.0">INotifyCollectionChanged</a> (like <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.objectmodel.observablecollection-1?view=net-5.0">ObservableCollection&lt;T&gt;</a>) as the value of <code class="language-plaintext highlighter-rouge">Person.Skills</code>.</p> <p>In Xaml-based frameworks you can use these two interfaces in your models and the framework will take care of handling the change events to update the UI. Unfortunately, Blazor is ignorant about these interfaces. <a href="https://github.com/phorks/phork-blazor-reactivity"><em>Phork.Blazor.Reactivity</em></a> is a library -which I‚Äôm the author of- that brings the support of these two interfaces to Blazor!</p> <p>Using <em>Phork.Blazor.Reactivity</em>, we can apply the following simple changes to the above component to make it reactive! (Assuming our models are modified to implement <code class="language-plaintext highlighter-rouge">INotifyPropertyChanged</code> and use <code class="language-plaintext highlighter-rouge">ObservableCollection&lt;T&gt;</code> correctly and <em>Phork.Blazor.Reactivity</em> is installed and configured in our project)</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@inherits ReactiveComponentBase

Name: @Observed(() =&gt; Person.Name)

<span class="nt">&lt;ul&gt;</span>
  @foreach (var skill in ObservedCollection(() =&gt; Person.Skills))
  {
    <span class="nt">&lt;li</span> <span class="err">@</span><span class="na">key=</span><span class="s">"skill"</span><span class="nt">&gt;</span>@Observed(() =&gt; skill.Title)<span class="nt">&lt;/li&gt;</span>
  }
<span class="nt">&lt;/ul&gt;</span>

<span class="nt">&lt;ChildComponent</span> <span class="na">Person=</span><span class="s">"@Person"</span> <span class="nt">/&gt;</span>

@code {
  [Parameter] public Person Person { get; set; }
}
</code></pre></div></div> <p>With <em>Phork.Blazor.Reactivity</em>, you can take advantage of <code class="language-plaintext highlighter-rouge">INotifyPropertyChanged</code> and <code class="language-plaintext highlighter-rouge">INotifyCollectionChanged</code> to create reactive components. The library will take care of watching changes for you. It doesn‚Äôt end here, there are more features available in the library that you can learn about in its documentation.</p> <p>Find out more:</p> <ul> <li><a href="https://github.com/phorks/phork-blazor-reactivity/blob/main/README.md">Documentation</a></li> <li><a href="https://github.com/phorks/phork-blazor-reactivity">GitHub Repository</a></li> <li><a href="https://www.nuget.org/packages/Phork.Blazor.Reactivity">NuGet package</a></li> </ul> <blockquote> <p>üéØ <strong>Bonus Tip</strong>: If you plan to use MVVM in your Blazor application, using <em>Phork.Blazor.Reactivty</em> will give you the luxury of reusing your existing cross-platform view models from your WPF/Xamarin.Forms applications with less effort.</p> </blockquote>]]></content><author><name>Pharaz Fadaei</name></author><category term="Programming"/><category term="C#"/><category term="Programming"/><category term="Blazor"/><category term="INotifyPropertyChanged"/><category term="INotifyCollectionChanged"/><summary type="html"><![CDATA[In Blazor, changes to the state of a component become visible to the user when the component re-renders. Blazor has some conventions to make a component automatically re-render when it thinks there is a chance for the component‚Äôs state to be changed. However these conventions might sometimes fail to detect changes that actually require a re-render. According to Microsoft docs, Blazor considers the following situations as the sources of state-changes and will re-render the component accordingly: When the set of parameters of a component is updated by its parent component. When a cascading value is updated. When an event on the component is raised or an external EventCallback that the component is subscribed to is invoked. When `StateHasChanged` method of the component is explicitly called. In simple scenarios, the first 3 conventions will be enough to keep your components reactive. But let your models and the relationship between your components get complicated, and you will most often than not find yourself explicitly calling StateHasChanged to make your components re-render. A common source of a state-change is a modification to a variable that is used (through binding) to render the component in the most recent render cycle. A variable can be a member (field or property) of the component (possibly a parameter), a nested member of direct members of the component or an item of a collection member of the component. Some UI frameworks already have the mechanisms to detect such modifications and will automatically make the component re-render (e.g. the reactivity system of Vue.js does so by replacing data of a component with proxies that are able to notify the component when they are changed, bindings in WPF/Xamarin.Forms are able to track changes by subscribing to INotifyPropertyChanged and INotifyCollectionChanged instances present in the binding path). But Blazor does not react to such changes if the source of the change does not fall into one of the conventions explained above. Consider the following sample component: Name: @(Person.Name) &lt;ul&gt; @foreach (var skill in Person.Skills) { &lt;li @key="skill"&gt;@(skill.Title)&lt;/li&gt; } &lt;/ul&gt; &lt;ChildComponent Person="@Person" /&gt; @code { [Parameter] public Person Person { get; set; } } Here if the child component changes Person.Name, adds a skill to Person.Skills, or changes the title of an existing skill, our component has no way to realize that it should re-render to reflect the changes, unless we modify the child component or our model class to make them notify our component when Person.Name is changed, Person.Skills collection is modified, or skill.Title is changed for all of the existing skills in Person.Skills and we modify our component to let Blazor know that the state has changed (by calling StateHasChanged) as the result of these notifications. Just imagine the amount of boilerplate code we need to write for every variable that the rendering of our component relies on! Fortunately, the infrastructure to let an object notify its changes is already available in .NET. The key is to make Person and Skill classes implement INotifyPropertyChanged and raise PropertyChanged event when Person.Name and Skill.Title get changed and to use a collection that implements INotifyCollectionChanged (like ObservableCollection&lt;T&gt;) as the value of Person.Skills. In Xaml-based frameworks you can use these two interfaces in your models and the framework will take care of handling the change events to update the UI. Unfortunately, Blazor is ignorant about these interfaces. Phork.Blazor.Reactivity is a library -which I‚Äôm the author of- that brings the support of these two interfaces to Blazor! Using Phork.Blazor.Reactivity, we can apply the following simple changes to the above component to make it reactive! (Assuming our models are modified to implement INotifyPropertyChanged and use ObservableCollection&lt;T&gt; correctly and Phork.Blazor.Reactivity is installed and configured in our project) @inherits ReactiveComponentBase Name: @Observed(() =&gt; Person.Name) &lt;ul&gt; @foreach (var skill in ObservedCollection(() =&gt; Person.Skills)) { &lt;li @key="skill"&gt;@Observed(() =&gt; skill.Title)&lt;/li&gt; } &lt;/ul&gt; &lt;ChildComponent Person="@Person" /&gt; @code { [Parameter] public Person Person { get; set; } } With Phork.Blazor.Reactivity, you can take advantage of INotifyPropertyChanged and INotifyCollectionChanged to create reactive components. The library will take care of watching changes for you. It doesn‚Äôt end here, there are more features available in the library that you can learn about in its documentation. Find out more: Documentation GitHub Repository NuGet package üéØ Bonus Tip: If you plan to use MVVM in your Blazor application, using Phork.Blazor.Reactivty will give you the luxury of reusing your existing cross-platform view models from your WPF/Xamarin.Forms applications with less effort.]]></summary></entry><entry><title type="html">C# Expression Trees!</title><link href="https://pharaz.com/2020/08/22/csharp-expression-trees/" rel="alternate" type="text/html" title="C# Expression Trees!"/><published>2020-08-22T00:00:00+00:00</published><updated>2020-08-22T00:00:00+00:00</updated><id>https://pharaz.com/2020/08/22/csharp-expression-trees</id><content type="html" xml:base="https://pharaz.com/2020/08/22/csharp-expression-trees/"><![CDATA[<p>Have you ever wondered how a property of an object can be passed to a method? I mean the property itself, not its value! Why does it matter to be able to pass a property, you might ask. Let me explain with an example. Let‚Äôs say we want to write a method that accepts a string property of an object and prints the name of the property followed by its value. How should this method be written? For the sake of demonstration, let‚Äôs suppose that we have a <em>Person</em> class that has two string properties, <em>FirstName</em> and <em>LastName</em>. <em>personInstance</em> is an instance of this class.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">Person</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FirstName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">LastName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//... inside the main method</span>
<span class="n">Person</span> <span class="n">personInstance</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Person</span>
<span class="p">{</span>
    <span class="n">FirstName</span> <span class="p">=</span> <span class="s">"John"</span><span class="p">,</span>
    <span class="n">LastName</span> <span class="p">=</span> <span class="s">"Doe"</span>
<span class="p">};</span>
</code></pre></div></div> <p>The goal here is to write a method <em>PrintProperty</em> in a way that if a property of an object is passed to it, it will print the name and the value of the property. For instance, if the method is called this way, <code class="language-plaintext highlighter-rouge">PrintProperty(FirstName property of personInstance)</code>, it will print ‚ÄúFirstName: John‚Äù. Now the question is, how can we define this <em>PrintProperty</em> method? How can we pass the property to it?</p> <p>First, let‚Äôs talk a bit about properties. In order for a property to be accessed at runtime, we need the property name and an object that has that property. Once we have this information, we can find the value of the property with help of <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection">reflection</a>. So, the problem is now reduced to finding a way to pass an object and a property name to a method. In this post, I am going to explain three different approaches to address this problem.</p> <h2 id="approach-1-the-naive-approach">Approach #1: The naive approach</h2> <p>We can simply pass the object and property name, and the rest can be handled by reflection.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">PrintProperty1</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">string</span> <span class="n">propertyName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">property</span> <span class="p">=</span> <span class="n">obj</span><span class="p">.</span><span class="nf">GetType</span><span class="p">().</span><span class="nf">GetProperty</span><span class="p">(</span><span class="n">propertyName</span><span class="p">);</span>

    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">propertyName</span><span class="p">}</span><span class="s">: </span><span class="p">{</span><span class="n">property</span><span class="p">.</span><span class="nf">GetValue</span><span class="p">(</span><span class="n">obj</span><span class="p">)}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ... inside the main method</span>
<span class="nf">PrintProperty1</span><span class="p">(</span><span class="n">personInstance</span><span class="p">,</span> <span class="s">"FirstName"</span><span class="p">);</span>
</code></pre></div></div> <p>Here, we are using a string to identify the property. But what if at some point we decide to change the name of the property to <em>Name</em> instead of <em>FirstName</em>? Or what prevents me from passing ‚ÄúInvalidProperty‚Äù as the property name? There‚Äôs no way to ensure <em>propertyName</em> is a property of <em>obj</em> at compile-time.</p> <h2 id="approach-2-using-nameof-expression">Approach #2: Using nameof expression</h2> <p>Before C# 6.0, there was no good way to obtain the name of a property programmatically. But C# 6.0 introduced <em>nameof</em> expression that is helpful in this situation.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">PrintProperty2</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">string</span> <span class="n">propertyName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">property</span> <span class="p">=</span> <span class="n">obj</span><span class="p">.</span><span class="nf">GetType</span><span class="p">().</span><span class="nf">GetProperty</span><span class="p">(</span><span class="n">propertyName</span><span class="p">);</span>

    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">propertyName</span><span class="p">}</span><span class="s">: </span><span class="p">{</span><span class="n">property</span><span class="p">.</span><span class="nf">GetValue</span><span class="p">(</span><span class="n">obj</span><span class="p">)}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ... inside the main method</span>
<span class="nf">PrintProperty2</span><span class="p">(</span><span class="n">personInstance</span><span class="p">,</span> <span class="k">nameof</span><span class="p">(</span><span class="n">personInstance</span><span class="p">.</span><span class="n">FirstName</span><span class="p">));</span>
</code></pre></div></div> <p>As you can see, the body of <em>PrintProperty2</em> is the same as <em>PrintProperty1</em>, what has changed, is how we pass the property name to it. Using <em>nameof</em> expression, if we change name of the property to <em>Name</em> at some point, it won‚Äôt compile. But since the parameter is string, I‚Äôm not forced to use <em>nameof</em> and still nothing prevents me from passing ‚ÄúInvalidProperty‚Äù as the property name. This approach is OK but doesn‚Äôt look cool to me. Since what we are trying to achieve, is to pass the <em>FirstName</em> property to the method, wouldn‚Äôt it be better if we could simply pass personInstance.FirstName? Well, the answer is we can, somehow! Expression trees are here to help! Before moving on to the third approach, let‚Äôs talk about expression trees a bit.</p> <p>You can be a C#/.net developer for years and have never heard of expression trees. Before explaining expression trees, I am going to ask you a simple question to test your knowledge of expression trees. Let‚Äôs assume that we‚Äôre going to assign the following lambda expression to a variable named <em>x</em>. <em>obj</em> is an object of a class that has an int property named <em>prop</em>. What kinds of possible types can replace <code class="language-plaintext highlighter-rouge">var</code> keyword below?</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">x</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">prop</span><span class="p">;</span>
</code></pre></div></div> <p>If your answer to this question does not include <code class="language-plaintext highlighter-rouge">Expression&lt;Func&lt;int&gt;&gt;</code>, you are probably ignorant of expression trees!</p> <p>Normally, when you assign an expression, <code class="language-plaintext highlighter-rouge">a+b</code> for instance, to a variable <em>x</em>, the expression is computed and its value is assigned to <em>x</em>. So, after it is assigned, <em>x</em> only knows the computed value and has no idea how the value is computed, therefore if you change the value of <em>a</em>, the value of <em>x</em> won‚Äôt change. It‚Äôs not the same for lambda expressions. If you assign a lambda expression, let‚Äôs say <code class="language-plaintext highlighter-rouge">() =&gt; a + b</code>, to a variable <em>f</em>, the value <code class="language-plaintext highlighter-rouge">a+b</code> is not computed at first. In contrast to the previous case, where the value got computed and stored in <em>x</em>, here, the instruction to produce the value is stored in <em>f</em>. Strictly speaking, <em>f</em> captures variables <em>a</em> and <em>b</em> and every time it gets invoked, it adds these two variables and returns the value. With the help of expression trees, you can create and manipulate these instructions.</p> <p>Cool as it may sound, it seems hard to find a real-world situation in which expression trees can come in handy. You might be surprised by the fact that how expression trees are being used in LINQ to Sql. For instance, <code class="language-plaintext highlighter-rouge">Where</code> extension method that is applied to <code class="language-plaintext highlighter-rouge">IEnumerable&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">Where</code> extension method that is used for <code class="language-plaintext highlighter-rouge">IQueryable&lt;T&gt;</code>, although look similar in usage and name, accept different type of parameters. Former expects a <code class="language-plaintext highlighter-rouge">Func&lt;T, bool&gt;</code> as the first parameter while the latter expects a <code class="language-plaintext highlighter-rouge">Expression&lt;Func&lt;T, bool&gt;&gt;</code>. You can learn more about this usage <a href="https://www.youtube.com/watch?v=ylaxq4koAkU">here</a>.</p> <p>Now, let‚Äôs see how expression trees can help us solve our main problem!</p> <h2 id="approach-3-expression-trees">Approach #3: Expression Trees!</h2> <p>As I mentioned above, we can just pass <code class="language-plaintext highlighter-rouge">personInstance.FirstName</code> to the method. But if we do so, what the method will get is the value of <code class="language-plaintext highlighter-rouge">personInstance.FirstName</code> which is string ‚ÄúJohn‚Äù. So, we can instead pass <code class="language-plaintext highlighter-rouge">() =&gt; personInstance.FirstName</code> as an expression to the method and analyse it to find the object and its property member.</p> <p><code class="language-plaintext highlighter-rouge">() =&gt; personInstance.FirstName</code> as an Expression, is a <code class="language-plaintext highlighter-rouge">LambdaExpression</code>, it has a <em>Body</em> property that defines what the lambda expression will return. The <em>Body</em> property in this case is a <code class="language-plaintext highlighter-rouge">MemberExpression</code> - since we are trying to access a member of another expression using the dot operator. The member expression itself has an <em>Expression</em> property, which defines the expression that we are trying to access its member and a <em>Member</em> property. <em>Member</em> property of the <code class="language-plaintext highlighter-rouge">MemberExpression</code> is a <code class="language-plaintext highlighter-rouge">MemberInfo</code> object that has a <em>Name</em> property, which in this case is ‚ÄúFirstName‚Äù. There is an implicit level of member accessing here. Since <em>personInstance</em> is defined inside the <em>main</em> method, it cannot be accessed elsewhere, hence, the lambda expression will capture the <em>personInstance</em> object and store it inside a compiler-generated class as a field named <em>personInstance</em>. So <em>personInstance</em> object is a property inside an implicit compiler-generated class. As a result <em>Expression</em> property of the member expression, in this case, is also a <code class="language-plaintext highlighter-rouge">MemberExpression</code> with its <em>Member</em> property being a <code class="language-plaintext highlighter-rouge">MemberInfo</code> with <em>personInstance</em> name and its <em>Expression</em> being a <code class="language-plaintext highlighter-rouge">ConstantExpression</code> that has that compiler-generated class as its value. Following diagram demonstrates how the expression tree of this simple lambda expression will look like.</p> <p><img src="/assets/img/expression_trees.png#center" alt="expression tree"/> <em>Expression tree of <code class="language-plaintext highlighter-rouge">() =&gt; personInstance.FirstName</code> (the diagram is made using <a href="https://app.diagrams.net/">draw.io</a>)</em></p> <p>Now we can use the above information to implement PrintProperty3 method.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">PrintProperty3</span><span class="p">(</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;&gt;</span> <span class="n">propertyExpression</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">memberExpression</span> <span class="p">=</span> <span class="n">propertyExpression</span><span class="p">.</span><span class="n">Body</span> <span class="k">as</span> <span class="n">MemberExpression</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">implicitMemberExpression</span> <span class="p">=</span> <span class="n">memberExpression</span><span class="p">.</span><span class="n">Expression</span> <span class="k">as</span> <span class="n">MemberExpression</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">objectName</span> <span class="p">=</span> <span class="n">implicitMemberExpression</span><span class="p">.</span><span class="n">Member</span><span class="p">.</span><span class="n">Name</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">constantExpression</span> <span class="p">=</span> <span class="n">implicitMemberExpression</span><span class="p">.</span><span class="n">Expression</span> <span class="k">as</span> <span class="n">ConstantExpression</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">owner</span> <span class="p">=</span> <span class="n">constantExpression</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>

    <span class="kt">var</span> <span class="n">obj</span> <span class="p">=</span> <span class="n">owner</span><span class="p">.</span><span class="nf">GetType</span><span class="p">().</span><span class="nf">GetField</span><span class="p">(</span><span class="n">objectName</span><span class="p">).</span><span class="nf">GetValue</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">property</span> <span class="p">=</span> <span class="n">memberExpression</span><span class="p">.</span><span class="n">Member</span> <span class="k">as</span> <span class="n">PropertyInfo</span><span class="p">;</span>

    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">property</span><span class="p">.</span><span class="n">Name</span><span class="p">}</span><span class="s">: </span><span class="p">{</span><span class="n">property</span><span class="p">.</span><span class="nf">GetValue</span><span class="p">(</span><span class="n">obj</span><span class="p">)}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ... inside the main method</span>
<span class="nf">PrintProperty3</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">personInstance</span><span class="p">.</span><span class="n">FirstName</span><span class="p">);</span>
</code></pre></div></div> <p>In this approach, the method body is longer compared to the ones in previous approaches. However, when it comes to using it, passing the property is more straightforward. We can feel that we‚Äôre actually passing a property. In this case if we decide to rename <em>FirstName</em> property to Name we will get a compilation error. This approach is not completely safe though, we can pass <code class="language-plaintext highlighter-rouge">() =&gt; ‚ÄúHello‚Äù</code> as the parameter! But at least we‚Äôre not relying on strings to specify properties. I personally prefer not to use nameof expression unless there is no better choice.</p> <p>We just learned a new technique to specify properties. In the next part I‚Äôll explain how this technique can be used in WPF/Xamarin.Forms applications. If you don‚Äôt know or care about WPF or Xamarin.Forms you can skip this part.</p> <h3 id="applications-in-wpfxamarinforms">Applications in WPF/Xamarin.Forms</h3> <p>XAML-based technologies in C# like WPF or Xamarin.Forms, provide an <code class="language-plaintext highlighter-rouge">ICommand</code> interface to implement command design pattern. It is common among developers to use a single <em>DelegateCommand</em> -or <em>RelayCommand</em>‚Äì class to create new commands instead of creating a new class and implementing <code class="language-plaintext highlighter-rouge">ICommand</code> for each new command. Let‚Äôs assume that you have a sign up form. There is a ‚ÄúI Agree to the Terms‚Äù checkbox that is bound to a bool property named Agreed in your view model. There is also a button that must be disabled if the checkbox is not checked. You create your command inside your view model this way:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// define SubmitCommand property inside the view model</span>
<span class="n">DelegateCommand</span> <span class="n">SubmitCommand</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// ... inside the constructor</span>
<span class="k">this</span><span class="p">.</span><span class="n">SubmitCommand</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DelegateCommand</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nf">Submit</span><span class="p">(),</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="n">Agreed</span><span class="p">);</span>
</code></pre></div></div> <p>Obviously, the submit button on your form must be bound to <em>SubmitCommand</em> property. This way, even if you check the checkbox, you‚Äôll notice that the button won‚Äôt be enabled. That‚Äôs because the button won‚Äôt automatically check your CanExecute command to see if it‚Äôs changed. If your CanExecute function depends on some of the properties in your view model, you should fire CanExecute event of DelegateCommand manually every time one of these properties is changed. It‚Äôs fine to add <code class="language-plaintext highlighter-rouge">this.SubmitCommand.RaiseCanExecuteChanged()</code> to the getter of <em>Agreed</em> property. But suppose that you have many commands that depend on <em>Agreed</em> property and also your <em>SubmitCommand</em> depends on some other properties. You‚Äôll end up with ugly getters, and it would become a headache to manage their relations. However, you can take advantage of <code class="language-plaintext highlighter-rouge">INotifyPropertyChanged</code> interface and use the technique explained above to tell your commands to observe the properties. You can implement a method in your DelegateCommand class to watch for property changes. And then you can simply initialize your <em>SubmitCommand</em> this way:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="n">SubmitCommand</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DelegateCommand</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nf">Submit</span><span class="p">(),</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="n">Agreed</span><span class="p">);</span>
<span class="k">this</span><span class="p">.</span><span class="n">SubmitCommand</span><span class="p">.</span><span class="nf">ObservesProperty</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="n">Agreed</span><span class="p">);</span>
</code></pre></div></div> <p>And you‚Äôre done.</p> <p>As a bonus, the Prism library has a nice implementation of <em>DelegateCommand</em> class with an <em>ObservesProperty</em> method. You can check it out on <a href="https://github.com/PrismLibrary/Prism/blob/master/src/Prism.Core/Commands/DelegateCommand.cs">their github</a>.</p>]]></content><author><name>Pharaz Fadaei</name></author><category term="Programming"/><category term="C#"/><category term="Programming"/><category term="Expression Trees"/><summary type="html"><![CDATA[Have you ever wondered how a property of an object can be passed to a method? I mean the property itself, not its value! Why does it matter to be able to pass a property, you might ask. Let me explain with an example. Let‚Äôs say we want to write a method that accepts a string property of an object and prints the name of the property followed by its value. How should this method be written? For the sake of demonstration, let‚Äôs suppose that we have a Person class that has two string properties, FirstName and LastName. personInstance is an instance of this class. public Person { public string FirstName { get; set; } public string LastName { get; set; } } //... inside the main method Person personInstance=new Person { FirstName="John", LastName="Doe" }; The goal here is to write a method PrintProperty in a way that if a property of an object is passed to it, it will print the name and the value of the property. For instance, if the method is called this way, PrintProperty(FirstName property of personInstance), it will print ‚ÄúFirstName: John‚Äù. Now the question is, how can we define this PrintProperty method? How can we pass the property to it? First, let‚Äôs talk a bit about properties. In order for a property to be accessed at runtime, we need the property name and an object that has that property. Once we have this information, we can find the value of the property with help of reflection. So, the problem is now reduced to finding a way to pass an object and a property name to a method. In this post, I am going to explain three different approaches to address this problem. Approach #1: The naive approach We can simply pass the object and property name, and the rest can be handled by reflection. static void PrintProperty1(object obj, string propertyName) { var property=obj.GetType().GetProperty(propertyName); Console.WriteLine($"{propertyName}: {property.GetValue(obj)}"); } // ... inside the main method PrintProperty1(personInstance, "FirstName"); Here, we are using a string to identify the property. But what if at some point we decide to change the name of the property to Name instead of FirstName? Or what prevents me from passing ‚ÄúInvalidProperty‚Äù as the property name? There‚Äôs no way to ensure propertyName is a property of obj at compile-time. Approach #2: Using nameof expression Before C# 6.0, there was no good way to obtain the name of a property programmatically. But C# 6.0 introduced nameof expression that is helpful in this situation. static void PrintProperty2(object obj, string propertyName) { var property=obj.GetType().GetProperty(propertyName); Console.WriteLine($"{propertyName}: {property.GetValue(obj)}"); } // ... inside the main method PrintProperty2(personInstance, nameof(personInstance.FirstName)); As you can see, the body of PrintProperty2 is the same as PrintProperty1, what has changed, is how we pass the property name to it. Using nameof expression, if we change name of the property to Name at some point, it won‚Äôt compile. But since the parameter is string, I‚Äôm not forced to use nameof and still nothing prevents me from passing ‚ÄúInvalidProperty‚Äù as the property name. This approach is OK but doesn‚Äôt look cool to me. Since what we are trying to achieve, is to pass the FirstName property to the method, wouldn‚Äôt it be better if we could simply pass personInstance.FirstName? Well, the answer is we can, somehow! Expression trees are here to help! Before moving on to the third approach, let‚Äôs talk about expression trees a bit. You can be a C#/.net developer for years and have never heard of expression trees. Before explaining expression trees, I am going to ask you a simple question to test your knowledge of expression trees. Let‚Äôs assume that we‚Äôre going to assign the following lambda expression to a variable named x. obj is an object of a class that has an int property named prop. What kinds of possible types can replace var keyword below? var x=() =&gt; obj.prop; If your answer to this question does not include Expression&lt;Func&lt;int&gt;&gt;, you are probably ignorant of expression trees! Normally, when you assign an expression, a+b for instance, to a variable x, the expression is computed and its value is assigned to x. So, after it is assigned, x only knows the computed value and has no idea how the value is computed, therefore if you change the value of a, the value of x won‚Äôt change. It‚Äôs not the same for lambda expressions. If you assign a lambda expression, let‚Äôs say () =&gt; a + b, to a variable f, the value a+b is not computed at first. In contrast to the previous case, where the value got computed and stored in x, here, the instruction to produce the value is stored in f. Strictly speaking, f captures variables a and b and every time it gets invoked, it adds these two variables and returns the value. With the help of expression trees, you can create and manipulate these instructions. Cool as it may sound, it seems hard to find a real-world situation in which expression trees can come in handy. You might be surprised by the fact that how expression trees are being used in LINQ to Sql. For instance, Where extension method that is applied to IEnumerable&lt;T&gt; and Where extension method that is used for IQueryable&lt;T&gt;, although look similar in usage and name, accept different type of parameters. Former expects a Func&lt;T, bool&gt; as the first parameter while the latter expects a Expression&lt;Func&lt;T, bool&gt;&gt;. You can learn more about this usage here. Now, let‚Äôs see how expression trees can help us solve our main problem! Approach #3: Expression Trees! As I mentioned above, we can just pass personInstance.FirstName to the method. But if we do so, what the method will get is the value of personInstance.FirstName which is string ‚ÄúJohn‚Äù. So, we can instead pass () =&gt; personInstance.FirstName as an expression to the method and analyse it to find the object and its property member. () =&gt; personInstance.FirstName as an Expression, is a LambdaExpression, it has a Body property that defines what the lambda expression will return. The Body property in this case is a MemberExpression - since we are trying to access a member of another expression using the dot operator. The member expression itself has an Expression property, which defines the expression that we are trying to access its member and a Member property. Member property of the MemberExpression is a MemberInfo object that has a Name property, which in this case is ‚ÄúFirstName‚Äù. There is an implicit level of member accessing here. Since personInstance is defined inside the main method, it cannot be accessed elsewhere, hence, the lambda expression will capture the personInstance object and store it inside a compiler-generated class as a field named personInstance. So personInstance object is a property inside an implicit compiler-generated class. As a result Expression property of the member expression, in this case, is also a MemberExpression with its Member property being a MemberInfo with personInstance name and its Expression being a ConstantExpression that has that compiler-generated class as its value. Following diagram demonstrates how the expression tree of this simple lambda expression will look like. Expression tree of () =&gt; personInstance.FirstName (the diagram is made using draw.io) Now we can use the above information to implement PrintProperty3 method. static void PrintProperty3(Expression&lt;Func&lt;string&gt;&gt; propertyExpression) { var memberExpression=propertyExpression.Body as MemberExpression; var implicitMemberExpression=memberExpression.Expression as MemberExpression; var objectName=implicitMemberExpression.Member.Name; var constantExpression=implicitMemberExpression.Expression as ConstantExpression; var owner=constantExpression.Value; var obj=owner.GetType().GetField(objectName).GetValue(owner); var property=memberExpression.Member as PropertyInfo; Console.WriteLine($"{property.Name}: {property.GetValue(obj)}"); } // ... inside the main method PrintProperty3(() =&gt; personInstance.FirstName); In this approach, the method body is longer compared to the ones in previous approaches. However, when it comes to using it, passing the property is more straightforward. We can feel that we‚Äôre actually passing a property. In this case if we decide to rename FirstName property to Name we will get a compilation error. This approach is not completely safe though, we can pass () =&gt; ‚ÄúHello‚Äù as the parameter! But at least we‚Äôre not relying on strings to specify properties. I personally prefer not to use nameof expression unless there is no better choice. We just learned a new technique to specify properties. In the next part I‚Äôll explain how this technique can be used in WPF/Xamarin.Forms applications. If you don‚Äôt know or care about WPF or Xamarin.Forms you can skip this part. Applications in WPF/Xamarin.Forms XAML-based technologies in C# like WPF or Xamarin.Forms, provide an ICommand interface to implement command design pattern. It is common among developers to use a single DelegateCommand -or RelayCommand‚Äì class to create new commands instead of creating a new class and implementing ICommand for each new command. Let‚Äôs assume that you have a sign up form. There is a ‚ÄúI Agree to the Terms‚Äù checkbox that is bound to a bool property named Agreed in your view model. There is also a button that must be disabled if the checkbox is not checked. You create your command inside your view model this way: // define SubmitCommand property inside the view model DelegateCommand SubmitCommand { get; set; } // ... inside the constructor this.SubmitCommand = new DelegateCommand(this.Submit(), () =&gt; this.Agreed); Obviously, the submit button on your form must be bound to SubmitCommand property. This way, even if you check the checkbox, you‚Äôll notice that the button won‚Äôt be enabled. That‚Äôs because the button won‚Äôt automatically check your CanExecute command to see if it‚Äôs changed. If your CanExecute function depends on some of the properties in your view model, you should fire CanExecute event of DelegateCommand manually every time one of these properties is changed. It‚Äôs fine to add this.SubmitCommand.RaiseCanExecuteChanged() to the getter of Agreed property. But suppose that you have many commands that depend on Agreed property and also your SubmitCommand depends on some other properties. You‚Äôll end up with ugly getters, and it would become a headache to manage their relations. However, you can take advantage of INotifyPropertyChanged interface and use the technique explained above to tell your commands to observe the properties. You can implement a method in your DelegateCommand class to watch for property changes. And then you can simply initialize your SubmitCommand this way: this.SubmitCommand = new DelegateCommand(this.Submit(), () =&gt; this.Agreed); this.SubmitCommand.ObservesProperty(() =&gt; this.Agreed); And you‚Äôre done. As a bonus, the Prism library has a nice implementation of DelegateCommand class with an ObservesProperty method. You can check it out on their github.]]></summary></entry></feed>