{"componentChunkName":"component---src-components-tag-archive-layout-tsx","path":"/tag/inotifycollectionchanged/","result":{"data":{"allMdx":{"edges":[{"node":{"id":"605d4ee8-e594-5242-9aec-0954368bb2d6","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": 3,\n  \"title\": \"Automatic Component State Management in Blazor using INotifyPropertyChanged and INotifyCollectionChanged\",\n  \"date\": \"2021-02-23T00:00:00.000Z\",\n  \"author\": \"Pharaz Fadaei\",\n  \"layout\": \"post\",\n  \"guid\": \"https://pharaz.com/?p=3\",\n  \"permalink\": \"/blazor-reactivity/\",\n  \"dsq_thread_id\": [\"1000000003\"],\n  \"categories\": [\"Programming\"],\n  \"tags\": [\"C#\", \"Programming\", \"Blazor\", \"State Management\", \"INotifyPropertyChanged\", \"INotifyCollectionChanged\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In Blazor, changes to the state of a component become visible to the user when the component re-renders. Blazor has some conventions to make a component automatically re-render when it thinks there is a chance for the component\\u2019s state to be changed. According to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/aspnet/core/blazor/components/rendering?view=aspnetcore-5.0\"\n  }, \"Microsoft docs\"), \", Blazor considers the following situations as the sources of state-changes and will re-render the component accordingly:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"When the set of parameters of a component is updated by its parent component.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"When a cascading value is updated.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"When an event on the component is raised or an external EventCallback that the component is subscribed to is invoked.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"When \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"StateHasChanged\"), \" method of the component is explicitly called.\")), mdx(\"p\", null, \"In simple scenarios, the first 3 conventions will be enough to keep your components reactive. But let your models and the relationship between your components get complicated, and you will most often than not find yourself explicitly calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StateHasChanged\"), \" to make your components re-render.\"), mdx(\"p\", null, \"A common source of a state-change is a modification to a variable that is used (through binding) to render the component in the most recent render cycle. A variable can be a member (field or property) of the component (possibly a parameter), a nested member of direct members of the component or an item of a collection member of the component. Some \", mdx(\"abbr\", {\n    parentName: \"p\",\n    \"title\": \"User Interface\"\n  }, \"UI\"), \" frameworks already have the mechanisms to detect such modifications and will automatically make the component re-render (e.g. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://vuejs.org/v2/guide/reactivity.html\"\n  }, \"the reactivity system of Vue.js\"), \" does so by replacing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data\"), \" of a component with proxies that are able to notify the component when they are changed, bindings in WPF/Xamarin.Forms are able to track changes by subscribing to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INotifyPropertyChanged\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INotifyCollectionChanged\"), \" instances present in the binding path). But Blazor does not react to such changes if the source of the change does not fall into one of the conventions explained above.\"), mdx(\"p\", null, \"Consider the following sample component:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"Name: @(Person.Name)\\n\\n<ul>\\n  @foreach (var skill in Person.Skills)\\n  {\\n    <li @key=\\\"skill\\\">@(skill.Title)</li>\\n  }\\n</ul>\\n\\n<ChildComponent Person=\\\"@Person\\\" />\\n\\n@code {\\n  [Parameter] public Person Person { get; set; }\\n}\\n\")), mdx(\"p\", null, \"Here if the child component changes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person.Name\"), \", adds a skill to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person.Skills\"), \", or changes the title of an existing skill, our component has no way to realize that it should re-render to reflect the changes, unless we modify the child component or our model class to make them notify our component when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person.Name\"), \" is changed, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person.Skills\"), \" collection is modified, or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"skill.Title\"), \" is changed for all of the existing skills in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person.Skills\"), \" and we modify our component to let Blazor know that the state has changed (by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StateHasChanged\"), \") as the result of these notifications. Just imagine the amount of boilerplate code we need to write for every variable that the rendering of our component relies on!\"), mdx(\"p\", null, \"Fortunately, the infrastructure to let an object notify its changes is already available in .NET. The key is to make \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Skill\"), \" classes implement \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.inotifypropertychanged?view=net-5.0\"\n  }, \"INotifyPropertyChanged\"), \" and raise \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PropertyChanged\"), \" event when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person.Name\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Skill.Title\"), \" get changed and to use a collection that implements \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.specialized.inotifycollectionchanged?view=net-5.0\"\n  }, \"INotifyCollectionChanged\"), \" (like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.objectmodel.observablecollection-1?view=net-5.0\"\n  }, \"ObservableCollection\", \"<\", \"T>\"), \") as the value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person.Skills\"), \".\"), mdx(\"p\", null, \"In Xaml-based frameworks you can use these two interfaces in your models and the framework will take care of handling the change events to update the \", mdx(\"abbr\", {\n    parentName: \"p\",\n    \"title\": \"User Interface\"\n  }, \"UI\"), \". Unfortunately, Blazor is ignorant about these interfaces. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/phorks/phork-blazor-reactivity\"\n  }, mdx(\"em\", {\n    parentName: \"a\"\n  }, \"Phork.Blazor.Reactivity\")), \" is a library -which I\\u2019m the author of- that brings the support of these two interfaces to Blazor!\"), mdx(\"p\", null, \"Using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Phork.Blazor.Reactivity\"), \", we can apply the following simple changes to the above component to make it reactive! (Assuming our models are modified to implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INotifyPropertyChanged\"), \" and use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObservableCollection<T>\"), \" correctly and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Phork.Blazor.Reactivity\"), \" is installed and configured in our project)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-html\"\n  }, \"@inherits ReactiveComponentBase\\n\\nName: @Observed(() => Person.Name)\\n\\n<ul>\\n  @foreach (var skill in ObservedCollection(() => Person.Skills))\\n  {\\n    <li @key=\\\"skill\\\">@Observed(() => skill.Title)</li>\\n  }\\n</ul>\\n\\n<ChildComponent Person=\\\"@Person\\\" />\\n\\n@code {\\n  [Parameter] public Person Person { get; set; }\\n}\\n\")), mdx(\"p\", null, \"With \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Phork.Blazor.Reactivity\"), \", you can take advantage of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INotifyPropertyChanged\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INotifyCollectionChanged\"), \" to create reactive components. The library will take care of watching changes for you. It doesn\\u2019t end here, there are more features available in the library that you can learn about in its documentation.\"), mdx(\"p\", null, \"Find out more:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/phorks/phork-blazor-reactivity/blob/main/README.md\"\n  }, \"Documentation\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/phorks/phork-blazor-reactivity\"\n  }, \"GitHub Repository\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.nuget.org/packages/Phork.Blazor.Reactivity\"\n  }, \"NuGet package\"))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\uD83C\\uDFAF \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Bonus Tip\"), \": If you plan to use \", mdx(\"abbr\", {\n    parentName: \"p\",\n    \"title\": \"Model View ViewModel\"\n  }, \"MVVM\"), \" in your Blazor application, using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Phork.Blazor.Reactivty\"), \" will give you the luxury of reusing your existing cross-platform view models from your WPF/Xamarin.Forms applications with less effort.\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"In Blazor, changes to the state of a component become visible to the user when the component re-renders. Blazor has some conventions to make a component automatically re-render when it thinks there is a chance for the component's state to be changed…","fields":{"slug":"/2021/02/23/blazor-reactivity/"},"frontmatter":{"categories":["Programming"],"date":"2021-02-23T00:00:00.000Z","dateFormatted":"February 23, 2021","image":null,"last_modified_at":null,"layout":"post","tags":["C#","Programming","Blazor","State Management","INotifyPropertyChanged","INotifyCollectionChanged"],"title":"Automatic Component State Management in Blazor using INotifyPropertyChanged and INotifyCollectionChanged"},"file":{"__typename":"File","base":"2021-02-23-blazor-reactivity.md"}}}]}},"pageContext":{"tag":"INotifyCollectionChanged"}},"staticQueryHashes":["1751019152","1751019152","3700271243","3700271243"]}