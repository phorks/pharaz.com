{"componentChunkName":"component---src-pages-archive-tsx","path":"/archive/","result":{"data":{"allMdx":{"edges":[{"node":{"id":"605d4ee8-e594-5242-9aec-0954368bb2d6","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": 3,\n  \"title\": \"Automatic Component State Management in Blazor using INotifyPropertyChanged and INotifyCollectionChanged\",\n  \"date\": \"2021-02-23T00:00:00.000Z\",\n  \"author\": \"Pharaz Fadaei\",\n  \"layout\": \"post\",\n  \"guid\": \"https://pharaz.com/?p=3\",\n  \"permalink\": \"/blazor-reactivity/\",\n  \"dsq_thread_id\": [\"1000000003\"],\n  \"categories\": [\"Programming\"],\n  \"tags\": [\"C#\", \"Programming\", \"Blazor\", \"State Management\", \"INotifyPropertyChanged\", \"INotifyCollectionChanged\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In Blazor, changes to the state of a component become visible to the user when the component re-renders. Blazor has some conventions to make a component automatically re-render when it thinks there is a chance for the component\\u2019s state to be changed. According to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/aspnet/core/blazor/components/rendering?view=aspnetcore-5.0\"\n  }, \"Microsoft docs\"), \", Blazor considers the following situations as the sources of state-changes and will re-render the component accordingly:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"When the set of parameters of a component is updated by its parent component.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"When a cascading value is updated.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"When an event on the component is raised or an external EventCallback that the component is subscribed to is invoked.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"When \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"StateHasChanged\"), \" method of the component is explicitly called.\")), mdx(\"p\", null, \"In simple scenarios, the first 3 conventions will be enough to keep your components reactive. But let your models and the relationship between your components get complicated, and you will most often than not find yourself explicitly calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StateHasChanged\"), \" to make your components re-render.\"), mdx(\"p\", null, \"A common source of a state-change is a modification to a variable that is used (through binding) to render the component in the most recent render cycle. A variable can be a member (field or property) of the component (possibly a parameter), a nested member of direct members of the component or an item of a collection member of the component. Some \", mdx(\"abbr\", {\n    parentName: \"p\",\n    \"title\": \"User Interface\"\n  }, \"UI\"), \" frameworks already have the mechanisms to detect such modifications and will automatically make the component re-render (e.g. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://vuejs.org/v2/guide/reactivity.html\"\n  }, \"the reactivity system of Vue.js\"), \" does so by replacing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data\"), \" of a component with proxies that are able to notify the component when they are changed, bindings in WPF/Xamarin.Forms are able to track changes by subscribing to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INotifyPropertyChanged\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INotifyCollectionChanged\"), \" instances present in the binding path). But Blazor does not react to such changes if the source of the change does not fall into one of the conventions explained above.\"), mdx(\"p\", null, \"Consider the following sample component:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"Name: @(Person.Name)\\n\\n<ul>\\n  @foreach (var skill in Person.Skills)\\n  {\\n    <li @key=\\\"skill\\\">@(skill.Title)</li>\\n  }\\n</ul>\\n\\n<ChildComponent Person=\\\"@Person\\\" />\\n\\n@code {\\n  [Parameter] public Person Person { get; set; }\\n}\\n\")), mdx(\"p\", null, \"Here if the child component changes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person.Name\"), \", adds a skill to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person.Skills\"), \", or changes the title of an existing skill, our component has no way to realize that it should re-render to reflect the changes, unless we modify the child component or our model class to make them notify our component when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person.Name\"), \" is changed, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person.Skills\"), \" collection is modified, or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"skill.Title\"), \" is changed for all of the existing skills in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person.Skills\"), \" and we modify our component to let Blazor know that the state has changed (by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StateHasChanged\"), \") as the result of these notifications. Just imagine the amount of boilerplate code we need to write for every variable that the rendering of our component relies on!\"), mdx(\"p\", null, \"Fortunately, the infrastructure to let an object notify its changes is already available in C#. The key is to make \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Skill\"), \" classes implement \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.inotifypropertychanged?view=net-5.0\"\n  }, \"INotifyPropertyChanged\"), \" and raise \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PropertyChanged\"), \" event when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person.Name\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Skill.Title\"), \" get changed and to use a collection that implements \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.specialized.inotifycollectionchanged?view=net-5.0\"\n  }, \"INotifyCollectionChanged\"), \" (like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.objectmodel.observablecollection-1?view=net-5.0\"\n  }, \"ObservableCollection\", \"<\", \"T>\"), \") as the value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person.Skills\"), \".\"), mdx(\"p\", null, \"In Xaml-based frameworks you can use these two interfaces in your models and the framework will take care of handling the change events to update the \", mdx(\"abbr\", {\n    parentName: \"p\",\n    \"title\": \"User Interface\"\n  }, \"UI\"), \". Unfortunately, Blazor is ignorant about these interfaces. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/phorks/phork-blazor/\"\n  }, mdx(\"em\", {\n    parentName: \"a\"\n  }, \"Phork.Blazor.Reactivity\")), \" is a library -which I\\u2019m the author of- that brings the support of these two interfaces to Blazor!\"), mdx(\"p\", null, \"Using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Phork.Blazor.Reactivity\"), \", we can apply the following simple changes to the above component to make it reactive! (Assuming our models are modified to implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INotifyPropertyChanged\"), \" and use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObservableCollection<T>\"), \" correctly and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Phork.Blazor.Reactivity\"), \" is installed and configured in our project)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-html\"\n  }, \"@inherits ReactiveComponentBase\\n\\nName: @Observed(() => Person.Name)\\n\\n<ul>\\n  @foreach (var skill in Observed(() => Person.Skills))\\n  {\\n    <li @key=\\\"skill\\\">@Observed(() => skill.Title)</li>\\n  }\\n</ul>\\n\\n<ChildComponent Person=\\\"@Person\\\" />\\n\\n@code {\\n  [Parameter] public Person Person { get; set; }\\n}\\n\")), mdx(\"p\", null, \"With \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Phork.Blazor.Reactivity\"), \", you can take advantage of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INotifyPropertyChanged\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INotifyCollectionChanged\"), \" to create reactive components. The library will take care of watching changes for you. It doesn\\u2019t end here, there are more features available in the library that you can learn about in its documentation.\"), mdx(\"p\", null, \"Find out more:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/phorks/phork-blazor/blob/main/docs/reactivity/README.md\"\n  }, \"Documentation\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/phorks/phork-blazor/\"\n  }, \"GitHub Repository\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.nuget.org/packages/Phork.Blazor.Reactivity\"\n  }, \"NuGet package\"))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\uD83C\\uDFAF \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Bonus Tip\"), \": If you plan to use \", mdx(\"abbr\", {\n    parentName: \"p\",\n    \"title\": \"Model View ViewModel\"\n  }, \"MVVM\"), \" in your Blazor application, using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Phork.Blazor.Reactivty\"), \" will give you the luxury of reusing your existing cross-platform view models from your WPF/Xamarin.Forms applications with less effort.\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"In Blazor, changes to the state of a component become visible to the user when the component re-renders. Blazor has some conventions to make a component automatically re-render when it thinks there is a chance for the component's state to be changed…","fields":{"slug":"/2021/02/23/blazor-reactivity/"},"frontmatter":{"categories":["Programming"],"date":"2021-02-23T00:00:00.000Z","dateFormatted":"February 23, 2021","image":null,"last_modified_at":null,"layout":"post","tags":["C#","Programming","Blazor","State Management","INotifyPropertyChanged","INotifyCollectionChanged"],"title":"Automatic Component State Management in Blazor using INotifyPropertyChanged and INotifyCollectionChanged"},"file":{"__typename":"File","base":"2021-02-23-blazor-reactivity.md"}}},{"node":{"id":"d291ce36-0c32-581f-9c79-cde62509e0f9","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": 2,\n  \"title\": \"C# Expression Trees!\",\n  \"date\": \"2020-08-22T00:00:00.000Z\",\n  \"author\": \"Pharaz Fadaei\",\n  \"layout\": \"post\",\n  \"guid\": \"https://pharaz.com/?p=2\",\n  \"permalink\": \"/2020/08/22/csharp-expression-trees/\",\n  \"dsq_thread_id\": [\"1000000002\"],\n  \"categories\": [\"Programming\"],\n  \"tags\": [\"C#\", \"Programming\", \"Expression Trees\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Have you ever wondered how a property of an object can be passed to a method? I mean the property itself, not its value! Why does it matter to be able to pass a property, you might ask. Let me explain with an example. Let\\u2019s say we want to write a method that accepts a string property of an object and prints the name of the property followed by its value. How should this method be written?\"), mdx(\"p\", null, \"For the sake of demonstration, let\\u2019s suppose that we have a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Person\"), \" class that has two string properties, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FirstName\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"LastName\"), \". \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"personInstance\"), \" is an instance of this class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public Person\\n{\\n    public string FirstName { get; set; }\\n    public string LastName { get; set; }\\n}\\n\\n//... inside the main method\\nPerson personInstance = new Person\\n{\\n    FirstName = \\\"John\\\",\\n    LastName = \\\"Doe\\\"\\n};\\n\")), mdx(\"p\", null, \"The goal here is to write a method \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"PrintProperty\"), \" in a way that if a property of an object is passed to it, it will print the name and the value of the property. For instance, if the method is called this way, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PrintProperty(FirstName property of personInstance)\"), \", it will print \\u201CFirstName: John\\u201D. Now the question is, how can we define this \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"PrintProperty\"), \" method? How can we pass the property to it?\"), mdx(\"p\", null, \"First, let\\u2019s talk a bit about properties. In order for a property to be accessed at runtime, we need the property name and an object that has that property. Once we have this information, we can find the value of the property with help of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection\"\n  }, \"reflection\"), \". So, the problem is now reduced to finding a way to pass an object and a property name to a method. In this post, I am going to explain three different approaches to address this problem.\"), mdx(\"h2\", null, \"Approach #1: The naive approach\"), mdx(\"p\", null, \"We can simply pass the object and property name, and the rest can be handled by reflection.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"static void PrintProperty1(object obj, string propertyName)\\n{\\n    var property = obj.GetType().GetProperty(propertyName);\\n\\n    Console.WriteLine($\\\"{propertyName}: {property.GetValue(obj)}\\\");\\n}\\n\\n// ... inside the main method\\nPrintProperty1(personInstance, \\\"FirstName\\\");\\n\")), mdx(\"p\", null, \"Here, we are using a string to identify the property. But what if at some point we decide to change the name of the property to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Name\"), \" instead of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FirstName\"), \"? Or what prevents me from passing \\u201CInvalidProperty\\u201D as the property name? There\\u2019s no way to ensure \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"propertyName\"), \" is a property of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"obj\"), \" at compile-time.\"), mdx(\"h2\", null, \"Approach #2: Using nameof expression\"), mdx(\"p\", null, \"Before C# 6.0, there was no good way to obtain the name of a property programmatically. But C# 6.0 introduced \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"nameof\"), \" expression that is helpful in this situation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"static void PrintProperty2(object obj, string propertyName)\\n{\\n    var property = obj.GetType().GetProperty(propertyName);\\n\\n    Console.WriteLine($\\\"{propertyName}: {property.GetValue(obj)}\\\");\\n}\\n\\n// ... inside the main method\\nPrintProperty2(personInstance, nameof(personInstance.FirstName));\\n\")), mdx(\"p\", null, \"As you can see, the body of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"PrintProperty2\"), \" is the same as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"PrintProperty1\"), \", what has changed, is how we pass the property name to it. Using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"nameof\"), \" expression, if we change name of the property to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Name\"), \" at some point, it won\\u2019t compile. But since the parameter is string, I\\u2019m not forced to use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"nameof\"), \" and still nothing prevents me from passing \\u201CInvalidProperty\\u201D as the property name. This approach is OK but doesn\\u2019t look cool to me. Since what we are trying to achieve, is to pass the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FirstName\"), \" property to the method, wouldn\\u2019t it be better if we could simply pass personInstance.FirstName? Well, the answer is we can, somehow! Expression trees are here to help! Before moving on to the third approach, let\\u2019s talk about expression trees a bit.\"), mdx(\"p\", null, \"You can be a C#/.net developer for years and have never heard of expression trees. Before explaining expression trees, I am going to ask you a simple question to test your knowledge of expression trees. Let\\u2019s assume that we\\u2019re going to assign the following lambda expression to a variable named \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"x\"), \". \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"obj\"), \" is an object of a class that has an int property named \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"prop\"), \". What kinds of possible types can replace \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var\"), \" keyword below?\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"var x = () => obj.prop;\\n\")), mdx(\"p\", null, \"If your answer to this question does not include \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Expression<Func<int>>\"), \", you are probably ignorant of expression trees!\"), mdx(\"p\", null, \"Normally, when you assign an expression, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a+b\"), \" for instance, to a variable \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"x\"), \", the expression is computed and its value is assigned to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"x\"), \". So, after it is assigned, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"x\"), \" only knows the computed value and has no idea how the value is computed, therefore if you change the value of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"a\"), \", the value of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"x\"), \" won\\u2019t change. It\\u2019s not the same for lambda expressions. If you assign a lambda expression, let\\u2019s say \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"() => a + b\"), \", to a variable \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"f\"), \", the value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a+b\"), \" is not computed at first. In contrast to the previous case, where the value got computed and stored in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"x\"), \", here, the instruction to produce the value is stored in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"f\"), \". Strictly speaking, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"f\"), \" captures variables \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"a\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"b\"), \" and every time it gets invoked, it adds these two variables and returns the value. With the help of expression trees, you can create and manipulate these instructions.\"), mdx(\"p\", null, \"Cool as it may sound, it seems hard to find a real-world situation in which expression trees can come in handy. You might be surprised by the fact that how expression trees are being used in LINQ to Sql. For instance, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Where\"), \" extension method that is applied to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEnumerable<T>\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Where\"), \" extension method that is used for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable<T>\"), \", although look similar in usage and name, accept different type of parameters. Former expects a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Func<T, bool>\"), \" as the first parameter while the latter expects a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Expression<Func<T, bool>>\"), \". You can learn more about this usage \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=ylaxq4koAkU\"\n  }, \"here\"), \".\"), mdx(\"p\", null, \"Now, let\\u2019s see how expression trees can help us solve our main problem!\"), mdx(\"h2\", null, \"Approach #3: Expression Trees!\"), mdx(\"p\", null, \"As I mentioned above, we can just pass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"personInstance.FirstName\"), \" to the method. But if we do so, what the method will get is the value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"personInstance.FirstName\"), \" which is string \\u201CJohn\\u201D. So, we can instead pass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"() => personInstance.FirstName\"), \" as an expression to the method and analyse it to find the object and its property member.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"() => personInstance.FirstName\"), \" as an Expression, is a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LambdaExpression\"), \", it has a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Body\"), \" property that defines what the lambda expression will return. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Body\"), \" property in this case is a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MemberExpression\"), \" - since we are trying to access a member of another expression using the dot operator. The member expression itself has an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Expression\"), \" property, which defines the expression that we are trying to access its member and a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Member\"), \" property. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Member\"), \" property of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MemberExpression\"), \" is a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MemberInfo\"), \" object that has a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Name\"), \" property, which in this case is \\u201CFirstName\\u201D. There is an implicit level of member accessing here. Since \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"personInstance\"), \" is defined inside the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"main\"), \" method, it cannot be accessed elsewhere, hence, the lambda expression will capture the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"personInstance\"), \" object and store it inside a compiler-generated class as a field named \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"personInstance\"), \". So \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"personInstance\"), \" object is a property inside an implicit compiler-generated class. As a result \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Expression\"), \" property of the member expression, in this case, is also a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MemberExpression\"), \" with its \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Member\"), \" property being a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MemberInfo\"), \" with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"personInstance\"), \" name and its \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Expression\"), \" being a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConstantExpression\"), \" that has that compiler-generated class as its value. Following diagram demonstrates how the expression tree of this simple lambda expression will look like.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"521px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"73.33333333333334%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAAC8ElEQVQ4y41TSUwTYRT+WwwEwQREPZh4kGCEBKMxoFf0qAeiJkaPHtSDF2M46NHlpCgHcY2iEoIYJCJLKe1sLQWmdGg7Xei+2BbaUtrSlbL1OTMYlh6Ql7y8me9/870373s/Qv8sPaES8zGlpC5FKMIQJvFcVEkBFxejCrI/TWBH+fM4LhOhvVh6clwgTKsUV4O43DVLyONBCo/75KOxCInjSwry2AahfG+EvIFjejP5Iqosba5rqN5+vkIr9062bP8lxEXmS0neO9gQM/Xd0ss+Psr7Rq5krb01XVVcQQCUoN/vjXD1D1XExzWPtAUWtJCf1QCEtQDzOkjbsbVV5896Ic89KN6VaMKhRJo5FaL1v4VEAO1BmCNuJCzDrXHz0LtF88ATCBJNXHcivsPpoVdi8PeIkqZulGJfCxwZ8+ctQk/CW1ixlPPyAqyC80PbgTYaEARVwkwhZNiZHQVz8ZgLq+kY/HDq+u3LhzlItNFRUgxB9T7unR9HaV/73RNG6Yt6yHVXbQoZYXYKpZ9lOmn7REamGV0foSV5jVudMYXZN8I8HdTGGEL4haRN7gux0pWIUZaPzWDLKZvcvuYeOLsxV+nWX2oDmofy6dEJGSN1SeghJ/es1vo199FNhIJ+oTsEYeJM1on1LRgllohREoiaRsyrXrITYgphrdxOW5HWsyTqH/dv20EAMe+76Ffe1FhZ1tbSVFJ7/AA/0/2FCdEs9705ZCpqPndnEzyN7gkxAPYKfYip/TbQ0fj2e9tJDiopFO/py091Hb3Y+UlLtN66AEcEdNDQg2jvGBp3U0jvNggdajx0q8qiBJIlgNTjMDajBK2fGSJsw2X8OevLVVuD6z8M3kxI704C60mDzpWcN/lzXzfLdanbEaYmBMUUM8Q1XCeTKE2UmjKSU5hWRuKs7IEjGygWhPRkn8XyAOOsHzDaCvJJC0xZwuCNc4taaH39w/+9VbguXDlliz1nPSk940wkGUciYfCmdWpr9PFfJrfHLkM5VX0AAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"expression tree\",\n    \"title\": \"expression tree\",\n    \"src\": \"/static/0c48987bbb97379b00fefd263fd6d5c2/bb9c5/expression_trees.png\",\n    \"srcSet\": [\"/static/0c48987bbb97379b00fefd263fd6d5c2/e9ff0/expression_trees.png 180w\", \"/static/0c48987bbb97379b00fefd263fd6d5c2/f21e7/expression_trees.png 360w\", \"/static/0c48987bbb97379b00fefd263fd6d5c2/bb9c5/expression_trees.png 521w\"],\n    \"sizes\": \"(max-width: 521px) 100vw, 521px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  }), \"\\n    \"), \"\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Expression tree of \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"() => personInstance.FirstName\"), \" \", \"(\", \"the diagram is made using \", mdx(\"a\", {\n    parentName: \"em\",\n    \"href\": \"https://app.diagrams.net/\"\n  }, \"draw.io\"), \")\")), mdx(\"p\", null, \"Now we can use the above information to implement PrintProperty3 method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"static void PrintProperty3(Expression<Func<string>> propertyExpression)\\n{\\n    var memberExpression = propertyExpression.Body as MemberExpression;\\n    var implicitMemberExpression = memberExpression.Expression as MemberExpression;\\n    var objectName = implicitMemberExpression.Member.Name;\\n    var constantExpression = implicitMemberExpression.Expression as ConstantExpression;\\n    var owner = constantExpression.Value;\\n\\n    var obj = owner.GetType().GetField(objectName).GetValue(owner);\\n    var property = memberExpression.Member as PropertyInfo;\\n\\n    Console.WriteLine($\\\"{property.Name}: {property.GetValue(obj)}\\\");\\n}\\n\\n// ... inside the main method\\nPrintProperty3(() => personInstance.FirstName);\\n\")), mdx(\"p\", null, \"In this approach, the method body is longer compared to the ones in previous approaches. However, when it comes to using it, passing the property is more straightforward. We can feel that we\\u2019re actually passing a property. In this case if we decide to rename \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FirstName\"), \" property to Name we will get a compilation error. This approach is not completely safe though, we can pass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"() => \\u201CHello\\u201D\"), \" as the parameter! But at least we\\u2019re not relying on strings to specify properties. I personally prefer not to use nameof expression unless there is no better choice.\"), mdx(\"p\", null, \"We just learned a new technique to specify properties. In the next part I\\u2019ll explain how this technique can be used in WPF/Xamarin.Forms applications. If you don\\u2019t know or care about WPF or Xamarin.Forms you can skip this part.\"), mdx(\"h3\", null, \"Applications in WPF/Xamarin.Forms\"), mdx(\"p\", null, \"\", mdx(\"abbr\", {\n    parentName: \"p\",\n    \"title\": \"Extensible Application Markup Language\"\n  }, \"XAML\"), \"-based technologies in C# like WPF or Xamarin.Forms, provide an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ICommand\"), \" interface to implement command design pattern. It is common among developers to use a single \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DelegateCommand\"), \" -or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"RelayCommand\"), \"\\u2013 class to create new commands instead of creating a new class and implementing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ICommand\"), \" for each new command. Let\\u2019s assume that you have a sign up form. There is a \\u201CI Agree to the Terms\\u201D checkbox that is bound to a bool property named Agreed in your view model. There is also a button that must be disabled if the checkbox is not checked. You create your command inside your view model this way:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"// define SubmitCommand property inside the view model\\nDelegateCommand SubmitCommand { get; set; }\\n\\n// ... inside the constructor\\nthis.SubmitCommand = new DelegateCommand(this.Submit(), () => this.Agreed);\\n\")), mdx(\"p\", null, \"Obviously, the submit button on your form must be bound to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"SubmitCommand\"), \" property. This way, even if you check the checkbox, you\\u2019ll notice that the button won\\u2019t be enabled. That\\u2019s because the button won\\u2019t automatically check your CanExecute command to see if it\\u2019s changed. If your CanExecute function depends on some of the properties in your view model, you should fire CanExecute event of DelegateCommand manually every time one of these properties is changed. It\\u2019s fine to add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this.SubmitCommand.RaiseCanExecuteChanged()\"), \" to the getter of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Agreed\"), \" property. But suppose that you have many commands that depend on \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Agreed\"), \" property and also your \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"SubmitCommand\"), \" depends on some other properties. You\\u2019ll end up with ugly getters, and it would become a headache to manage their relations. However, you can take advantage of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INotifyPropertyChanged\"), \" interface and use the technique explained above to tell your commands to observe the properties. You can implement a method in your DelegateCommand class to watch for property changes. And then you can simply initialize your \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"SubmitCommand\"), \" this way:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"this.SubmitCommand = new DelegateCommand(this.Submit(), () => this.Agreed);\\nthis.SubmitCommand.ObservesProperty(() => this.Agreed);\\n\")), mdx(\"p\", null, \"And you\\u2019re done.\"), mdx(\"p\", null, \"As a bonus, Prism library has a nice implementation of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DelegateCommand\"), \" class with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ObservesProperty\"), \" method. You can check it out on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/PrismLibrary/Prism/blob/master/src/Prism.Core/Commands/DelegateCommand.cs\"\n  }, \"their github\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Have you ever wondered how a property of an object can be passed to a method? I mean the property itself, not its value! Why does it matter to be able to pass a property, you might ask. Let me explain with an example. Let’s say we want to write a…","fields":{"slug":"/2020/08/22/csharp-expression-trees/"},"frontmatter":{"categories":["Programming"],"date":"2020-08-22T00:00:00.000Z","dateFormatted":"August 22, 2020","image":null,"last_modified_at":null,"layout":"post","tags":["C#","Programming","Expression Trees"],"title":"C# Expression Trees!"},"file":{"__typename":"File","base":"2020-08-22-csharp-expression-trees.md"}}},{"node":{"id":"52002bb0-9221-5b8c-845c-51288093e004","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": 1,\n  \"title\": \"Welcome!\",\n  \"date\": \"2020-08-20T00:00:00.000Z\",\n  \"author\": \"Pharaz Fadaei\",\n  \"layout\": \"post\",\n  \"guid\": \"https://pharaz.com/?p=1\",\n  \"permalink\": \"/2020/08/20/welcome/\",\n  \"dsq_thread_id\": [\"1000000001\"],\n  \"categories\": [\"Uncategorized\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Creating my first blog on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://fa.wikipedia.org/wiki/%D8%A8%D9%84%D8%A7%DA%AF%D9%81%D8%A7\"\n  }, \"Blogfa\"), \" when I was 10, has been one of the geekiest things I\\u2019ve ever done in my life. Being able to finally have an address of my own on the web was like a dream come true for me. Since then, I have created a number of blogs, none of which have been successful. Despite my inner desire to write, I have never been a successful blogger, actually, I have never been a blogger at all! All I did was sporadically write some random blog posts and then lose all the interest and motivation!\"), mdx(\"p\", null, \"This time it\\u2019s going to be different, I have a new set of motivations and reasons to blog! I have realized that to be a successful blogger, it takes desire, consistency, and planning.\"), mdx(\"p\", null, \"I intend to share my experiences, opinions, and adventures here. You may find posts mostly about computers, programming, games, and puzzles.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Creating my first blog on  Blogfa  when I was 10, has been one of the geekiest things I've ever done in my life. Being able to finally have an address of my own on the web was like a dream come true for me. Since then, I have created a number of…","fields":{"slug":"/2020/08/20/welcome/"},"frontmatter":{"categories":["Uncategorized"],"date":"2020-08-20T00:00:00.000Z","dateFormatted":"August 20, 2020","image":null,"last_modified_at":null,"layout":"post","tags":null,"title":"Welcome!"},"file":{"__typename":"File","base":"2020-08-20-welcome.md"}}}]}},"pageContext":{}},"staticQueryHashes":["1751019152","1751019152","3700271243","3700271243"]}